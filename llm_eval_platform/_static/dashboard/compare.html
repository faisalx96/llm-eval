<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>قيِّم • Compare Runs</title>
  <link rel="icon" type="image/png" href="./static/qym_icon.png">
  <link rel="stylesheet" href="./static/dashboard.css">
  <script src="./static/metrics.js"></script>
  <style>
    /* Compare-specific styles */
    .compare-container {
      padding: var(--space-lg);
      overflow-y: auto;
      height: calc(100vh - 100px);
    }

    .compare-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-md);
      border-bottom: 1px solid var(--border-default);
    }

    .compare-title {
      font-size: var(--font-lg);
      font-weight: 600;
      color: var(--text-primary);
    }

    .compare-subtitle {
      font-size: var(--font-sm);
      color: var(--text-muted);
      margin-top: 4px;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      color: var(--accent-primary);
      text-decoration: none;
      font-size: var(--font-sm);
    }

    .back-link:hover {
      text-decoration: underline;
    }

    /* Summary cards grid */
    .compare-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-md);
      margin-bottom: var(--space-xl);
    }

    .run-summary-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
    }

    .run-summary-card .run-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .remove-run {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: var(--font-sm);
    }

    .run-summary-card .remove-run:hover {
      background: var(--error-dim);
      color: var(--error);
    }

    .run-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .run-summary-card .run-name {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      color: var(--text-primary);
      word-break: break-all;
    }

    /* Confluence publishing removed */

    .run-summary-card .run-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .stats-row {
      display: flex;
      justify-content: space-between;
      padding: var(--space-xs) 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .run-summary-card .stats-row:last-child {
      border-bottom: none;
    }

    .run-summary-card .stat-label {
      color: var(--text-muted);
      font-size: var(--font-sm);
    }

    .run-summary-card .stat-val {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-primary);
    }

    .run-summary-card .stat-val.score-5 { color: var(--score-5); }
    .run-summary-card .stat-val.score-4 { color: var(--score-4); }
    .run-summary-card .stat-val.score-3 { color: var(--score-3); }
    .run-summary-card .stat-val.score-2 { color: var(--score-2); }
    .run-summary-card .stat-val.score-1 { color: var(--score-1); }

    /* Comparison Stats Section */
    .comparison-stats {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
      margin-bottom: var(--space-xl);
    }

    .comparison-stats h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .stats-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .stats-row {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
    }

    .stat-box {
      background: var(--bg-elevated);
      border-radius: 6px;
      padding: var(--space-sm) var(--space-md);
      flex: 1;
      min-width: 120px;
    }

    .stat-box.wide {
      flex: 100%;
      padding: var(--space-md);
    }

    .stat-box .stat-title {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .stat-info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: var(--accent-primary);
      color: var(--bg-primary);
      font-size: 10px;
      font-weight: 700;
      font-style: italic;
      font-family: Georgia, serif;
      cursor: help;
      position: relative;
      text-transform: lowercase;
      flex-shrink: 0;
    }

    .stat-info-icon:hover {
      background: var(--text-primary);
      color: var(--bg-primary);
      transform: scale(1.1);
    }

    .stat-info-tooltip {
      display: none;
      position: absolute;
      bottom: calc(100% + 8px);
      left: 0;
      background: var(--bg-elevated);
      border: 1px solid var(--border-default);
      border-radius: 6px;
      padding: 10px 12px;
      width: 240px;
      font-size: var(--font-sm);
      font-weight: 400;
      font-style: normal;
      font-family: var(--font-sans);
      color: var(--text-secondary);
      text-transform: none;
      letter-spacing: normal;
      line-height: 1.5;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: left;
    }

    .stat-info-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 12px;
      border: 6px solid transparent;
      border-top-color: var(--border-default);
    }

    .stat-info-icon:hover .stat-info-tooltip {
      display: block;
    }

    .stat-box .stat-main {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
    }

    .stat-box.wide .stat-main {
      font-size: var(--font-lg);
    }

    .stat-box .stat-main.score-5 { color: var(--score-5); }
    .stat-box .stat-main.score-4 { color: var(--score-4); }
    .stat-box .stat-main.score-3 { color: var(--score-3); }
    .stat-box .stat-main.score-2 { color: var(--score-2); }
    .stat-box .stat-main.score-1 { color: var(--score-1); }

    .stat-box .stat-detail {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* Win/Loss bars */
    .win-loss-bar {
      display: flex;
      height: 28px;
      border-radius: 4px;
      overflow: hidden;
      margin-top: var(--space-sm);
      gap: 2px;
    }

    .win-loss-bar .segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-xs);
      font-weight: 600;
      color: #fff;
      transition: flex 0.3s;
      min-width: 0;
      padding: 0 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .win-loss-bar .segment.tie {
      background: var(--text-muted);
    }

    .win-loss-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .win-loss-legend .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: var(--font-xs);
      color: var(--text-secondary);
    }

    .win-loss-legend .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .win-loss-legend .legend-count {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    /* Distribution bar */
    .distribution-bar {
      display: flex;
      height: 32px;
      border-radius: 4px;
      overflow: hidden;
      gap: 2px;
      margin-top: var(--space-sm);
    }

    .dist-segment {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 0;
      padding: 2px 4px;
      color: #fff;
      font-size: var(--font-xs);
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .dist-segment .dist-label {
      font-weight: 700;
      font-size: var(--font-sm);
    }

    .dist-segment .dist-count {
      font-size: 10px;
      opacity: 0.9;
    }

    .dist-segment.dist-zero {
      background: var(--error);
    }

    .dist-segment.dist-all {
      background: var(--success);
    }

    .dist-segment.dist-partial {
      background: var(--warning);
    }

    .distribution-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .dist-legend-item {
      display: inline-flex;
      gap: 4px;
    }

    .dist-legend-item strong {
      color: var(--text-secondary);
    }

    /* Metrics comparison table */
    .metrics-comparison {
      margin-bottom: var(--space-xl);
    }

    .metrics-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .metrics-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
    }

    .metrics-table th,
    .metrics-table td {
      padding: var(--space-sm) var(--space-md);
      text-align: left;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metrics-table th:not(:first-child),
    .metrics-table td:not(:first-child) {
      text-align: center;
    }

    .metrics-table thead th {
      background: var(--bg-elevated);
      font-size: var(--font-xs);
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metrics-table tbody td {
      font-size: var(--font-sm);
    }

    .metrics-table .metric-name {
      font-family: var(--font-mono);
      color: var(--text-secondary);
    }

    .metrics-table .metric-val {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    .metrics-table .metric-val.score-5 { color: var(--score-5); }
    .metrics-table .metric-val.score-4 { color: var(--score-4); }
    .metrics-table .metric-val.score-3 { color: var(--score-3); }
    .metrics-table .metric-val.score-2 { color: var(--score-2); }
    .metrics-table .metric-val.score-1 { color: var(--score-1); }

    .metrics-table .metric-val.best {
      background: var(--success-dim);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .metrics-table .diff {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .metrics-table .diff.positive {
      color: var(--success);
    }

    .metrics-table .diff.negative {
      color: var(--error);
    }

    /* Side-by-side items view */
    .items-comparison {
      margin-bottom: var(--space-xl);
    }

    .items-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .items-filter {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .filter-count {
      font-size: var(--font-sm);
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .filter-count .count-num {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .items-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .item-comparison-row {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-md);
    }

    .item-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding-bottom: var(--space-sm);
      border-bottom: 1px solid var(--border-subtle);
    }

    .item-index {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-muted);
    }

    .item-input-row,
    .item-expected-row {
      background: var(--bg-elevated);
      padding: var(--space-sm);
      border-radius: 4px;
    }

    .item-input-row .input-label,
    .item-expected-row .expected-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .item-input-row .input-text,
    .item-expected-row .expected-text {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-secondary);
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .item-expected-row {
      background: var(--success-dim);
      border-left: 3px solid var(--success);
    }

    .item-expected-row .expected-label {
      color: var(--success);
    }

    .item-outputs-row {
      display: grid;
      grid-template-columns: repeat(var(--run-count, 2), 1fr);
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .item-run-output {
      border-left: 3px solid var(--border-default);
      padding-left: var(--space-sm);
      background: var(--bg-elevated);
      border-radius: 0 4px 4px 0;
      padding: var(--space-sm);
    }

    .item-run-output .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
      flex-wrap: wrap;
      gap: 4px;
    }

    .item-run-output .run-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .item-run-output .output-badges {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .item-run-output .metric-badge,
    .item-run-output .latency-badge {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-surface);
    }

    .item-run-output .metric-badge.score-5 { background: var(--success-dim); color: var(--score-5); }
    .item-run-output .metric-badge.score-4 { background: rgba(132, 204, 22, 0.15); color: var(--score-4); }
    .item-run-output .metric-badge.score-3 { background: rgba(234, 179, 8, 0.15); color: var(--score-3); }
    .item-run-output .metric-badge.score-2 { background: rgba(249, 115, 22, 0.15); color: var(--score-2); }
    .item-run-output .metric-badge.score-1 { background: var(--error-dim); color: var(--score-1); }

    .item-run-output .latency-badge {
      color: var(--text-muted);
    }

    .item-run-output .start-badge {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-surface);
      color: var(--text-muted);
    }

    .item-run-output .trace-link {
      display: inline-flex;
      align-items: center;
      padding: 1px 5px;
      background: rgba(225, 29, 72, 0.15);
      color: #e11d48;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
      text-decoration: none;
      transition: background 0.15s;
    }

    .item-run-output .trace-link:hover {
      background: rgba(225, 29, 72, 0.25);
    }

    .item-run-output .output-text {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-secondary);
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 150px;
      overflow-y: auto;
    }

    .metric-edit-block {
      margin-top: 6px;
      padding: 6px;
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 6px;
    }
    .metric-edit-title {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .metric-edit-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-xs);
    }
    .metric-edit-controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .metric-edit-controls.hidden { display: none; }
    .metric-edit-block.hidden { display: none; }
    .metric-edit-input {
      width: 90px;
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-default);
      border-radius: 6px;
      padding: 4px 6px;
      font-family: var(--font-mono);
      font-size: var(--font-xs);
    }
    .metric-edit-save {
      background: transparent;
      border: 1px solid var(--border-default);
      color: var(--text-primary);
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: var(--font-xs);
    }
    .metric-edit-save:disabled { opacity: 0.6; cursor: default; }
    .metric-edit-status {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }
    .metric-edit-badge {
      display: inline-flex;
      align-items: center;
      padding: 1px 5px;
      background: rgba(34,197,94,0.15);
      color: var(--success);
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
    }
    .metric-edit-badge::before {
      content: "●";
      font-size: 7px;
      margin-right: 4px;
    }
    .metric-edit-open {
      background: #1f2430;
      border: none;
      color: #a7b0c0;
      border-radius: 6px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 6px;
      line-height: 1;
      opacity: 0.95;
    }
    .metric-edit-open:hover {
      opacity: 1;
      background: #222a36;
      color: #c3c9d6;
    }
    .metric-edit-meta {
      margin-top: 4px;
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: var(--space-sm);
      margin-top: var(--space-lg);
    }

    .pagination button {
      padding: var(--space-xs) var(--space-md);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .pagination button:hover:not(:disabled) {
      background: var(--bg-hover);
    }

    .pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination .page-info {
      display: flex;
      align-items: center;
      font-size: var(--font-sm);
      color: var(--text-muted);
    }

    /* Empty/loading states */
    .compare-loading,
    .compare-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 300px;
      color: var(--text-muted);
    }

    .compare-loading .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border-default);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: var(--space-md);
    }

    /* Formatted object/dict display styles */
    .formatted-object,
    .formatted-array {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      line-height: 1.6;
    }

    .formatted-row {
      padding: 6px 0;
      padding-left: var(--space-md);
      border-left: 2px solid var(--border-subtle);
      margin-left: 2px;
      margin-bottom: 4px;
    }

    .formatted-row:hover {
      background: var(--bg-hover);
      border-left-color: var(--accent-primary);
    }

    .formatted-key {
      color: #f472b6;
      font-weight: 600;
      display: block;
      margin-bottom: 4px;
      text-transform: uppercase;
      font-size: var(--font-xs);
      letter-spacing: 0.5px;
    }

    .formatted-string {
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      display: block;
      line-height: 1.5;
    }

    .formatted-number {
      color: #fbbf24;
      font-weight: 600;
    }

    .formatted-boolean {
      color: #a855f7;
      font-weight: 600;
    }

    .formatted-null {
      color: var(--text-muted);
      font-style: italic;
    }

    .formatted-array-item {
      padding: 6px 0;
      padding-left: var(--space-md);
      border-left: 2px solid var(--border-subtle);
      margin-left: 2px;
      margin-bottom: 4px;
    }

    .formatted-array-item:hover {
      background: var(--bg-hover);
      border-left-color: var(--accent-primary);
    }

    .formatted-index {
      color: #60a5fa;
      font-size: var(--font-xs);
      margin-right: 4px;
      font-weight: 600;
    }

    /* Shared toggle button for metric details */
    .item-metric-details-toggle {
      margin-top: var(--space-md);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
    }

    .metric-details-toggle {
      font-size: var(--font-sm);
      color: var(--accent-primary);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 4px;
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
    }

    .metric-details-toggle:hover {
      background: var(--bg-hover);
      border-color: var(--accent-primary);
    }

    /* Per-run metric details (inside each run output) */
    .run-metric-details {
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
      display: none;
    }

    .run-metric-details.expanded {
      display: block;
    }

    .metric-detail-row {
      padding: 8px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metric-detail-row:last-child {
      border-bottom: none;
    }

    .metric-detail-name {
      font-size: var(--font-sm);
      color: #f472b6;
      font-weight: 600;
      margin-bottom: 6px;
      display: block;
    }

    .metric-detail-value {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.6;
    }

    /* Metric tabs */
    .metric-tabs {
      display: flex;
      gap: 2px;
      background: var(--bg-elevated);
      padding: 3px;
      border-radius: 6px;
      width: fit-content;
    }

    .metric-tab {
      padding: 6px 16px;
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .metric-tab:hover {
      color: var(--text-secondary);
      background: var(--bg-hover);
    }

    .metric-tab.active {
      color: var(--text-primary);
      background: var(--bg-surface);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Metric tabs row - contains tabs and threshold control */
    .metric-tabs-row {
      display: flex;
      align-items: center;
      gap: var(--space-lg);
      margin-bottom: var(--space-md);
      flex-wrap: wrap;
    }

    /* Threshold control */
    .threshold-control {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .threshold-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .threshold-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 120px;
      height: 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .threshold-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 212, 170, 0.4);
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .threshold-slider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 0 3px 10px rgba(0, 212, 170, 0.5);
    }

    .threshold-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--accent-primary);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 212, 170, 0.4);
    }

    .threshold-slider::-moz-range-track {
      background: var(--bg-elevated);
      height: 6px;
      border-radius: 3px;
    }

    .threshold-value {
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      font-weight: 600;
      color: var(--accent-primary);
      min-width: 40px;
    }

    /* Metric selector for items */
    .items-filter-row {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
      flex-wrap: wrap;
    }

    .filter-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Winner indicator in item rows */
    .metric-winner {
      background: var(--success-dim);
      border-radius: 3px;
      padding: 0 4px;
      margin-left: 4px;
      font-size: var(--font-xs);
      color: var(--success);
    }

    .metric-score-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      padding: 2px 0;
    }
    .metric-score-meta {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .winner-badge {
      display: inline-flex;
      align-items: center;
      padding: 1px 5px;
      background: rgba(234, 179, 8, 0.2);
      color: #f59e0b;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
    }

    .metric-score-row.highlighted {
      background: var(--bg-hover);
      margin: 0 -4px;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .metric-score-name {
      font-size: var(--font-xs);
      color: var(--text-muted);
      min-width: 80px;
    }

    .metric-score-value {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      font-weight: 600;
    }

    .metric-scores-inline {
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
    }
  </style>
</head>
<body>
  <!-- Minimal header -->
  <header class="stats-bar">
    <div class="stats-bar-left">
      <div class="logo">
        <img src="./static/qym_text.png" alt="قيِّم" class="logo-text-img" />
      </div>
      <div class="stat-cells">
        <div class="stat-cell">
          <span class="stat-label">COMPARING</span>
          <span class="stat-value" id="run-count">—</span>
        </div>
        <div class="stat-cell">
          <span class="stat-label">TOTAL ITEMS</span>
          <span class="stat-value" id="total-items">—</span>
        </div>
        <div class="stat-cell">
          <span class="stat-label">METRICS</span>
          <span class="stat-value" id="metric-count">—</span>
        </div>
      </div>
    </div>
  </header>

  <main class="compare-container">
    <div class="compare-loading" id="loading">
      <div class="spinner"></div>
      <span>Loading comparison data...</span>
    </div>

    <div class="compare-empty" id="empty" style="display: none;">
      <div style="font-size: 48px; margin-bottom: var(--space-md);">∅</div>
      <h2>No runs to compare</h2>
      <p>Select at least 2 runs from the dashboard to compare.</p>
      <a href="" class="back-link" id="back-link-empty">← Back to Dashboard</a>
    </div>

    <div id="compare-content" style="display: none;">
      <div class="compare-header-bar">
        <div>
          <div class="compare-title">Run Comparison</div>
          <div class="compare-subtitle" id="compare-subtitle">Comparing evaluation runs</div>
        </div>
        <a href="" class="back-link" id="back-link-header">← Back to Dashboard</a>
      </div>

      <!-- Run summaries -->
      <div class="compare-summary" id="run-summaries"></div>

      <!-- Metrics comparison -->
      <div class="metrics-comparison">
        <h3>Metric Averages</h3>
        <table class="metrics-table" id="metrics-table">
          <thead id="metrics-thead"></thead>
          <tbody id="metrics-tbody"></tbody>
        </table>
      </div>

      <!-- Comparison Statistics -->
      <div class="comparison-stats" id="comparison-stats">
        <h3>Comparison Overview</h3>
        <div class="metric-tabs-row">
          <div class="metric-tabs" id="overview-metric-tabs"></div>
          <div class="threshold-control" id="threshold-control" style="display: none;">
            <span class="threshold-label">Pass if ≥</span>
            <input type="range" id="threshold-slider" class="threshold-slider" min="0" max="100" step="5" value="80">
            <span class="threshold-value" id="threshold-value">80%</span>
          </div>
        </div>
        <div class="stats-grid" id="stats-grid"></div>
      </div>

      <!-- Side-by-side items -->
      <div class="items-comparison">
        <h3>Item-by-Item Comparison</h3>
        <div class="items-filter-row">
          <span class="filter-label">Metric:</span>
          <select id="items-metric-select" class="filter-select"></select>
          <span class="filter-label">Filter:</span>
          <select id="item-filter" class="filter-select">
            <option value="all">All Items</option>
            <option value="different">Different Outputs</option>
            <option value="errors">With Errors</option>
            <option value="all_correct">All Runs Correct</option>
            <option value="all_wrong">No Run Correct</option>
            <option value="rarely_solved">Rarely Solved (≤25%)</option>
            <option value="unique_solve">Uniquely Solved (1 run only)</option>
          </select>
          <span class="filter-label">Winner:</span>
          <select id="run-winner-filter" class="filter-select">
            <option value="any">Any Winner</option>
          </select>
          <span class="filter-count" id="filter-count"></span>
        </div>
        <div class="items-grid" id="items-grid"></div>
        <div class="pagination" id="pagination"></div>
      </div>
    </div>
  </main>

  <script>
    (() => {
      'use strict';

      // Base URL handling for proxy/subpath compatibility
      const BASE_URL = (() => {
        const loc = window.location;
        let base = loc.pathname;
        if (!base.endsWith('/')) {
          base = base.substring(0, base.lastIndexOf('/') + 1) || '/';
        }
        return loc.origin + base;
      })();

      function apiUrl(path) {
        const cleanPath = path.replace(/^\.?\//, '');
        return BASE_URL + cleanPath;
      }

      // Fix back links for subpath/proxy deployments.
      try {
        const backUrl = apiUrl('');
        const backHeader = document.getElementById('back-link-header');
        const backEmpty = document.getElementById('back-link-empty');
        if (backHeader) backHeader.href = backUrl;
        if (backEmpty) backEmpty.href = backUrl;
      } catch {}

      const COLORS = [
        '#00d4aa', '#00a8ff', '#a855f7', '#f472b6',
        '#fbbf24', '#60a5fa', '#34d399', '#fb923c'
      ];

      const state = {
        runs: [],
        allMetrics: [],
        selectedOverviewMetric: null,  // For Comparison Overview tabs
        selectedItemsMetric: null,     // For Item-by-Item filters
        itemFilter: 'all',
        winnerFilter: 'any',
        page: 1,
        pageSize: 20,
        comparisonStats: {},  // Now keyed by metric name
        metricThresholds: {},  // Per-metric threshold for "correct" (0-1 scale)
        metricIsBoolean: {},   // Per-metric flag: true if all scores are 0 or 1
        langfuseHost: '',      // Langfuse host URL
        langfuseProjectId: '', // Langfuse project ID
        // Confluence publishing removed
        publishedRuns: new Set(),
      };

      const el = (id) => document.getElementById(id);

      function getSuccessClass(rate) {
        if (rate >= 0.9) return 'score-5';
        if (rate >= 0.75) return 'score-4';
        if (rate >= 0.6) return 'score-3';
        if (rate >= 0.4) return 'score-2';
        return 'score-1';
      }

      // Use shared utilities from metrics.js
      const formatPercent = window.QymMetrics.formatPercent;
      const formatLatency = window.QymMetrics.formatLatency;

      function formatTaskStart(ms) {
        if (!ms || ms <= 0) return null;
        try {
          const d = new Date(ms);
          const pad = (n) => String(n).padStart(2, '0');
          const yyyy = d.getFullYear();
          const mm = pad(d.getMonth() + 1);
          const dd = pad(d.getDate());
          const hh = pad(d.getHours());
          const min = pad(d.getMinutes());
          const sec = pad(d.getSeconds());
          const ts = `${yyyy}-${mm}-${dd} ${hh}:${min}:${sec}`;
          return { ts };
        } catch {
          return null;
        }
      }

      function buildLangfuseTraceUrl(traceId) {
        if (!traceId || !state.langfuseHost || !state.langfuseProjectId) return null;
        const host = state.langfuseHost.replace(/\/$/, '');
        return `${host}/project/${state.langfuseProjectId}/traces/${traceId}`;
      }

      function buildLangfuseTraceUrlFromRun(traceId, runInfo) {
        const host = (runInfo.langfuse_host || '').replace(/\/$/, '');
        const projectId = runInfo.langfuse_project_id || '';
        if (!traceId || !host || !projectId) return null;
        return `${host}/project/${projectId}/traces/${traceId}`;
      }

      function buildDistributionBar(stats) {
        return stats.correctDistribution.map((count, idx) => {
          if (count === 0) return '';
          const pct = (count / stats.totalCompared * 100).toFixed(0);
          const isZero = idx === 0;
          const isAll = idx === state.runs.length;
          const colorClass = isZero ? 'dist-zero' : isAll ? 'dist-all' : 'dist-partial';
          return `<div class="dist-segment ${colorClass}" style="flex: ${count}" title="${idx}/${state.runs.length} correct: ${count} items (${pct}%)">
            <span class="dist-label">${idx}</span>
            <span class="dist-count">${count}</span>
          </div>`;
        }).join('');
      }

      async function loadComparisonData() {
        // Get selected files from sessionStorage
        const filesJson = sessionStorage.getItem('compareRuns');
        if (!filesJson) {
          showEmpty();
          return;
        }

        let files;
        try {
          files = JSON.parse(filesJson);
        } catch {
          showEmpty();
          return;
        }

        if (!Array.isArray(files) || files.length < 2) {
          showEmpty();
          return;
        }

        // Fetch comparison data from API
        const params = files.map(f => 'files=' + encodeURIComponent(f)).join('&');
        try {
          const compareResponse = await fetch(apiUrl('api/compare?' + params));
          const data = await compareResponse.json();
          state.publishedRuns = new Set();

          if (!data.runs || data.runs.length < 2) {
            showEmpty();
            return;
          }

          state.runs = data.runs;
          state.langfuseHost = data.langfuse_host || '';
          state.langfuseProjectId = data.langfuse_project_id || '';
          // Fallback: use per-run Langfuse config if top-level is incomplete
          if ((!state.langfuseHost || !state.langfuseProjectId) && data.runs?.length) {
            const firstRun = data.runs[0]?.run || {};
            state.langfuseHost = state.langfuseHost || firstRun.langfuse_host || '';
            state.langfuseProjectId = state.langfuseProjectId || firstRun.langfuse_project_id || '';
          }
          processRuns();
          render();
        } catch (err) {
          console.error('Failed to load comparison:', err);
          showEmpty();
        }
      }

      function processRuns() {
        // Collect all unique metrics
        const metricsSet = new Set();
        for (const run of state.runs) {
          const snap = run.snapshot || {};
          const names = snap.metric_names || run.run?.metric_names || [];
          names.forEach(m => metricsSet.add(m));
        }
        state.allMetrics = Array.from(metricsSet).sort();

        // Set default selected metrics
        if (state.allMetrics.length > 0) {
          state.selectedOverviewMetric = state.allMetrics[0];
          state.selectedItemsMetric = state.allMetrics[0];
        }

        // Update header stats
        el('run-count').textContent = state.runs.length;
        el('metric-count').textContent = state.allMetrics.length;

        // Calculate total items (use max across runs)
        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));
        el('total-items').textContent = maxItems;

        // Detect metric types (boolean vs continuous)
        detectMetricTypes();

        // Calculate comparison statistics for each metric
        state.comparisonStats = {};
        for (const metric of state.allMetrics) {
          state.comparisonStats[metric] = calculateComparisonStatsForMetric(metric);
        }

        // Populate metric selectors
        populateMetricSelectors();

        // Populate winner filter dropdown
        populateWinnerFilter();
      }

      function populateMetricSelectors() {
        // Overview metric tabs
        const tabsContainer = el('overview-metric-tabs');
        if (tabsContainer) {
          tabsContainer.innerHTML = state.allMetrics.map(metric =>
            `<button class="metric-tab ${metric === state.selectedOverviewMetric ? 'active' : ''}" data-metric="${metric}">${metric}</button>`
          ).join('');

          tabsContainer.querySelectorAll('.metric-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              state.selectedOverviewMetric = tab.dataset.metric;
              tabsContainer.querySelectorAll('.metric-tab').forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              updateThresholdControl();
              renderComparisonStats();
            });
          });
        }

        // Threshold slider (only for continuous metrics)
        const thresholdSlider = el('threshold-slider');
        const thresholdValue = el('threshold-value');
        if (thresholdSlider) {
          thresholdSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if (thresholdValue) thresholdValue.textContent = `${value}%`;
          });
          thresholdSlider.addEventListener('change', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value) && value >= 0 && value <= 100) {
              state.metricThresholds[state.selectedOverviewMetric] = value / 100;
              // Recalculate stats for this metric
              state.comparisonStats[state.selectedOverviewMetric] = calculateComparisonStatsForMetric(state.selectedOverviewMetric);
              // Also recalculate for items metric if different
              if (state.selectedItemsMetric && state.selectedItemsMetric !== state.selectedOverviewMetric) {
                state.comparisonStats[state.selectedItemsMetric] = calculateComparisonStatsForMetric(state.selectedItemsMetric);
              }
              renderComparisonStats();
              renderItems();
            }
          });
        }

        // Initial threshold control visibility
        updateThresholdControl();

        // Items metric selector dropdown
        const itemsMetricSelect = el('items-metric-select');
        if (itemsMetricSelect) {
          itemsMetricSelect.innerHTML = state.allMetrics.map(metric =>
            `<option value="${metric}" ${metric === state.selectedItemsMetric ? 'selected' : ''}>${metric}</option>`
          ).join('');

          itemsMetricSelect.addEventListener('change', (e) => {
            state.selectedItemsMetric = e.target.value;
            state.page = 1;
            populateWinnerFilter();
            renderItems();
          });
        }
      }

      // Show/hide threshold control based on metric type
      function updateThresholdControl() {
        const thresholdControl = el('threshold-control');
        const thresholdSlider = el('threshold-slider');
        const thresholdValue = el('threshold-value');
        if (!thresholdControl || !thresholdSlider) return;

        const metric = state.selectedOverviewMetric;
        if (!metric) {
          thresholdControl.style.display = 'none';
          return;
        }

        const isBoolean = state.metricIsBoolean[metric];
        if (isBoolean) {
          thresholdControl.style.display = 'none';
        } else {
          thresholdControl.style.display = 'flex';
          // Set slider value to current threshold (as percentage)
          const pct = Math.round((state.metricThresholds[metric] ?? 0.8) * 100);
          thresholdSlider.value = pct;
          if (thresholdValue) thresholdValue.textContent = `${pct}%`;
        }
      }

      // Detect if a metric is boolean (all scores are 0 or 1) and initialize threshold
      function detectMetricTypes() {
        for (const metricName of state.allMetrics) {
          let allBoolean = true;

          for (const run of state.runs) {
            const snap = run.snapshot || {};
            const rows = snap.rows || [];
            const metricNames = snap.metric_names || run.run?.metric_names || [];
            const metricIdx = metricNames.indexOf(metricName);

            if (metricIdx < 0) continue;

            for (const row of rows) {
              const v = (row.metric_values || [])[metricIdx];
              const n = parseFloat(v);
              if (!isNaN(n)) {
                // Check if score is NOT 0 or 1 (with tolerance)
                if (Math.abs(n) > 0.0001 && Math.abs(n - 1) > 0.0001) {
                  allBoolean = false;
                  break;
                }
              }
            }
            if (!allBoolean) break;
          }

          state.metricIsBoolean[metricName] = allBoolean;
          // Default threshold: 80% for continuous metrics
          if (!state.metricThresholds[metricName]) {
            state.metricThresholds[metricName] = 0.8;
          }
        }
      }

      function calculateComparisonStatsForMetric(metricName) {
        const stats = {
          wins: new Array(state.runs.length).fill(0),
          ties: 0,
          totalCompared: 0,
          avgScores: [],
          avgLatencies: [],
          scoreDelta: 0,
          latencyDelta: 0,
          agreementRate: 0,
          allCorrect: 0,
          allWrong: 0,
          passAtK: 0, // Items where at least one run scored 100%
          passHatK: 0, // Items where ALL runs scored 100%
          totalConsistencySum: 0, // Sum of per-item consistency scores
          totalReliabilitySum: 0, // Sum of per-item reliability (pass_count / K) for items with at least one pass
          itemsWithMultipleRuns: 0, // Count of items with K > 1 for consistency
          itemsWithAtLeastOnePass: 0, // Count of items where at least one run passed (for reliability)
          maxAtK: 0, // Sum of max scores across all items (best possible if you pick best run per item)
          failedCount: 0, // Total number of failed attempts across all items and runs
          correctDistribution: [], // How many items had 0, 1, 2, ... N runs correct
          overallAvgScore: 0,
          overallAvgLatency: 0,
          errorCounts: [],
          errorTypes: [],
          biggestWins: [],
          itemWinners: [], // For each item, which run won
        };

        // Collect all unique item_ids across all runs for proper alignment
        const allItemIds = new Set();
        for (const run of state.runs) {
          const rows = run.snapshot?.rows || [];
          for (const row of rows) {
            // Use item_id if available, otherwise fallback to index
            const itemId = row.item_id || String(row.index);
            allItemIds.add(itemId);
          }
        }
        const itemIdList = Array.from(allItemIds);

        // Create a map from item_id to array index for itemWinners tracking
        state.itemIdToIndex = {};
        itemIdList.forEach((id, idx) => { state.itemIdToIndex[id] = idx; });

        // Initialize correct distribution array (index = number of runs correct, value = count)
        stats.correctDistribution = new Array(state.runs.length + 1).fill(0);

        // Helper to get metric index for a run
        function getMetricIndex(run) {
          const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
          return metricNames.indexOf(metricName);
        }

        // Calculate per-run stats
        for (let runIdx = 0; runIdx < state.runs.length; runIdx++) {
          const run = state.runs[runIdx];
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricIdx = getMetricIndex(run);

          let scoreSum = 0, scoreCount = 0, latSum = 0, latCount = 0;
          let timeoutErrors = 0, runtimeErrors = 0, otherErrors = 0;

          for (const row of rows) {
            // Score for the selected metric (use centralized error handling)
            if (metricIdx >= 0) {
              const { score } = window.QymMetrics.getRowScore(row, metricIdx);
              if (score !== null) { scoreSum += score; scoreCount++; }
            }
            // Latency
            if (row.latency_ms && row.status === 'completed') {
              latSum += row.latency_ms;
              latCount++;
            }
            // Errors (use centralized check)
            if (window.QymMetrics.isErrorRow(row)) {
              const output = (row.output_full || row.output || '').toLowerCase();
              if (output.includes('timeout')) timeoutErrors++;
              else if (output.includes('error')) runtimeErrors++;
              else otherErrors++;
            }
          }

          stats.avgScores.push(scoreCount > 0 ? scoreSum / scoreCount : 0);
          stats.avgLatencies.push(latCount > 0 ? latSum / latCount : 0);
          stats.errorCounts.push(timeoutErrors + runtimeErrors + otherErrors);
          stats.errorTypes.push({ timeout: timeoutErrors, runtime: runtimeErrors, other: otherErrors });
        }

        // Compare items head-to-head using item_id for alignment
        let agreements = 0;
        for (const itemId of itemIdList) {
          const scoresWithStatus = state.runs.map((run) => {
            const snap = run.snapshot || {};
            const rows = snap.rows || [];
            // Match by item_id, fallback to index for legacy data
            const row = rows.find(r => (r.item_id || String(r.index)) === itemId);
            if (!row) return { score: null, failed: false };
            const metricIdx = getMetricIndex(run);
            if (metricIdx < 0) return { score: null, failed: false };
            // Use centralized error handling from metrics.js
            const { score, isError } = window.QymMetrics.getRowScore(row, metricIdx);
            return { score, failed: isError };
          });

          // Count failed attempts
          stats.failedCount += scoresWithStatus.filter(s => s.failed).length;

          const scores = scoresWithStatus.map(s => s.score);
          const validScores = scores.filter(s => s !== null);

          // Max@K: track the best score for this item across all runs (not affected by threshold)
          if (validScores.length > 0) {
            stats.maxAtK += Math.max(...validScores);
          }

          // Determine threshold for "correct": 1.0 for boolean, user-defined for continuous
          const isBoolean = state.metricIsBoolean[metricName];
          const threshold = isBoolean ? 0.9999 : state.metricThresholds[metricName];

          // Count distribution for ALL items (even those with missing data)
          const numCorrect = scores.filter(s => s !== null && s >= threshold).length;
          stats.correctDistribution[numCorrect]++;

          // For head-to-head comparison, need at least 2 valid scores
          if (validScores.length < 2) {
            stats.itemWinners.push(null);
            // Still count pass@k for items with any data
            if (numCorrect > 0) stats.passAtK++;
            if (scores.every(s => s === null || s < 0.0001)) stats.allWrong++;
            if (numCorrect === scores.filter(s => s !== null).length && numCorrect > 0) stats.allCorrect++;
            stats.totalCompared++;
            continue;
          }

          stats.totalCompared++;

          const maxScore = Math.max(...validScores);
          const minScore = Math.min(...validScores);
          const winners = scores.map((s, idx) => s === maxScore ? idx : -1).filter(x => x >= 0);

          // Check if ALL scores are the same (true tie)
          if (maxScore === minScore) {
            stats.ties++;
            stats.itemWinners.push('tie');
          } else if (winners.length === 1) {
            // Clear winner - only one run has the HIGHEST score (beat all others)
            stats.wins[winners[0]]++;
            stats.itemWinners.push(winners[0]);
            // Track biggest wins
            const diff = maxScore - minScore;
            stats.biggestWins.push({ itemId: itemId, winner: winners[0], diff, scores });
          } else {
            // Multiple runs tied for the highest score, but didn't beat everyone
            // This counts as a tie (no clear winner)
            stats.ties++;
            stats.itemWinners.push('tie');
          }

          // All correct / all wrong / pass@k (at least one run meets threshold)
          // Note: numCorrect was already calculated above using threshold
          const allCorrectItem = numCorrect === validScores.length && validScores.length > 0;
          const allZeroItem = validScores.every(s => s < 0.0001); // All scores are 0%

          if (allCorrectItem) stats.allCorrect++;
          if (allZeroItem) stats.allWrong++;
          if (numCorrect > 0) stats.passAtK++;

          // Pass^K: ALL runs meet threshold
          if (allCorrectItem) stats.passHatK++;

          // Consistency: binary agreement (do runs agree on pass/fail?)
          // Formula: 2 * max(passCount, failCount) / K - 1
          // Range: 0% (50/50 split) to 100% (all agree)
          if (validScores.length > 1) {
            const numFail = validScores.length - numCorrect;
            const maxAgreement = Math.max(numCorrect, numFail);
            const itemConsistency = (2 * maxAgreement / validScores.length) - 1;
            stats.totalConsistencySum += itemConsistency;
            stats.itemsWithMultipleRuns++;

            // Reliability: when it CAN answer correctly, how often does it?
            // Only include items with at least one passing run
            if (numCorrect > 0) {
              const itemReliability = numCorrect / validScores.length;
              stats.totalReliabilitySum += itemReliability;
              stats.itemsWithAtLeastOnePass++;
            }
          }

          // Agreement (runs scored similarly - within 10% of each other)
          const scoreRange = maxScore - minScore;
          if (scoreRange < 0.1) agreements++;
        }

        stats.agreementRate = stats.totalCompared > 0 ? agreements / stats.totalCompared : 0;

        // Calculate overall averages across all runs
        const validScoresAll = stats.avgScores.filter(s => s > 0);
        const validLatenciesAll = stats.avgLatencies.filter(l => l > 0);
        stats.overallAvgScore = validScoresAll.length > 0
          ? validScoresAll.reduce((a, b) => a + b, 0) / validScoresAll.length
          : 0;
        stats.overallAvgLatency = validLatenciesAll.length > 0
          ? validLatenciesAll.reduce((a, b) => a + b, 0) / validLatenciesAll.length
          : 0;

        // Score and latency deltas (comparing first two runs)
        if (state.runs.length >= 2) {
          stats.scoreDelta = stats.avgScores[0] - stats.avgScores[1];
          stats.latencyDelta = stats.avgLatencies[0] - stats.avgLatencies[1];
        }

        // Sort biggest wins
        stats.biggestWins.sort((a, b) => b.diff - a.diff);
        stats.biggestWins = stats.biggestWins.slice(0, 5);

        return stats;
      }

      function populateWinnerFilter() {
        const select = el('run-winner-filter');
        if (!select) return;

        // Save current value to restore after repopulating
        const currentValue = state.winnerFilter;

        let options = '<option value="any">Any Winner</option>';
        options += '<option value="tie">Ties Only</option>';

        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="win_${idx}">${name} Won</option>`;
        });

        // Add "Only X Solved" options for unique insights
        options += '<optgroup label="Uniquely Solved By">';
        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="only_${idx}">Only ${name}</option>`;
        });
        options += '</optgroup>';

        select.innerHTML = options;

        // Restore previous selection if it still exists
        if (select.querySelector(`option[value="${currentValue}"]`)) {
          select.value = currentValue;
        } else {
          state.winnerFilter = 'any';
        }
      }

      function removeRun(idx) {
        if (state.runs.length <= 2) return;

        // Remove from state
        state.runs.splice(idx, 1);

        // Update sessionStorage so it persists
        const filesJson = sessionStorage.getItem('compareRuns');
        if (filesJson) {
          try {
            const files = JSON.parse(filesJson);
            files.splice(idx, 1);
            sessionStorage.setItem('compareRuns', JSON.stringify(files));
          } catch {}
        }

        // Reset filters that might reference removed run
        state.winnerFilter = 'any';
        state.page = 1;

        // Reprocess and re-render
        processRuns();
        render();
      }

      function showEmpty() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'flex';
        el('compare-content').style.display = 'none';
      }

      function render() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'none';
        el('compare-content').style.display = 'block';

        renderSummaries();
        renderComparisonStats();
        renderMetricsTable();
        renderItems();
      }

      // Helper to create info icon with tooltip
      function infoIcon(tooltip) {
        return `<span class="stat-info-icon">i<span class="stat-info-tooltip">${tooltip}</span></span>`;
      }

      // Helper to get color class based on percentage (0-1) - matches getSuccessClass thresholds
      function scoreColorClass(value) {
        if (value >= 0.9) return 'score-5';
        if (value >= 0.75) return 'score-4';
        if (value >= 0.6) return 'score-3';
        if (value >= 0.4) return 'score-2';
        return 'score-1';
      }

      function renderComparisonStats() {
        const container = el('stats-grid');
        if (!container || !state.comparisonStats || !state.selectedOverviewMetric) return;

        const stats = state.comparisonStats[state.selectedOverviewMetric];
        if (!stats) return;
        const runNames = state.runs.map((r, i) => r.run?.run_name || `Run ${i + 1}`);
        const K = state.runs.length;

        // Build win/loss bar with proper colors
        const total = stats.totalCompared || 1;
        const winBarSegments = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          const count = stats.wins[idx];
          if (count === 0) return '';
          return `<div class="segment" style="flex: ${count}; background: ${color}">${count}</div>`;
        }).join('');
        const tieSegment = stats.ties > 0
          ? `<div class="segment tie" style="flex: ${stats.ties}">${stats.ties}</div>`
          : '';

        // Build legend
        const legendItems = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          return `<div class="legend-item">
            <div class="legend-dot" style="background: ${color}"></div>
            <span>${runNames[idx]}:</span>
            <span class="legend-count">${stats.wins[idx]}</span>
          </div>`;
        }).join('');
        const tieLegend = `<div class="legend-item">
          <div class="legend-dot" style="background: var(--text-muted)"></div>
          <span>Ties:</span>
          <span class="legend-count">${stats.ties}</span>
        </div>`;

        // Tooltips for each metric - adjust based on boolean vs continuous
        const isBoolean = state.metricIsBoolean[state.selectedOverviewMetric];
        const threshold = Math.round((state.metricThresholds[state.selectedOverviewMetric] ?? 0.8) * 100);
        const correctDef = isBoolean ? '100%' : `≥${threshold}%`;

        const tooltips = {
          passAtK: isBoolean
            ? `Percentage of items where <strong>at least one</strong> of the ${K} runs achieved a perfect score (100%). Measures coverage - can any run solve this item?`
            : `Percentage of items where <strong>at least one</strong> of the ${K} runs scored <strong>≥${threshold}%</strong>. Adjust the threshold above to change what counts as "correct".`,
          passHatK: isBoolean
            ? `Percentage of items where <strong>all ${K} runs</strong> achieved a perfect score (100%). Measures consistency - do all runs reliably solve this item?`
            : `Percentage of items where <strong>all ${K} runs</strong> scored <strong>≥${threshold}%</strong>. Adjust the threshold above to change what counts as "correct".`,
          maxAtK: `Average of the <strong>best score</strong> across all ${K} runs for each item. Shows the upper bound of what your runs can achieve.`,
          consistency: `Measures how often runs <strong>agree on pass/fail</strong> across ${K} runs. <strong>100%</strong> = all runs agree, <strong>0%</strong> = 50/50 split.`,
          reliability: `When an item <strong>CAN be solved</strong>, how often is it? Only includes items with <strong>≥1 passing run</strong>.`,
          failedCount: `Number of runs that <strong>threw an error</strong> (across all items). Errors are scored as 0%.`,
          avgScore: `The <strong>mean score</strong> across all items and all runs. A general measure of overall performance.`,
          avgLatency: `The <strong>mean response time</strong> across all items and all runs. Lower is better.`,
          winnerBreakdown: `Shows which run "won" (scored highest) for each item. Ties occur when multiple runs share the top score. Helps identify which run performs best most often.`,
          correctDist: isBoolean
            ? `Distribution showing how many runs got each item correct. "0 runs" = no run solved it, "${K} runs" = all runs solved it. Helps identify easy vs hard items.`
            : `Distribution showing how many runs scored ≥${threshold}% for each item. Adjust the threshold above to change what counts as "correct".`
        };

        container.innerHTML = `
          <div class="stats-row">
            <div class="stat-box">
              <div class="stat-title">Pass@${K} ${infoIcon(tooltips.passAtK)}</div>
              <div class="stat-main ${scoreColorClass(stats.passAtK / stats.totalCompared)}">${formatPercent(stats.passAtK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Pass^${K} ${infoIcon(tooltips.passHatK)}</div>
              <div class="stat-main ${scoreColorClass(stats.passHatK / stats.totalCompared)}">${formatPercent(stats.passHatK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Max@${K} ${infoIcon(tooltips.maxAtK)}</div>
              <div class="stat-main ${scoreColorClass(stats.maxAtK / stats.totalCompared)}">${formatPercent(stats.maxAtK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Consistency ${infoIcon(tooltips.consistency)}</div>
              <div class="stat-main ${scoreColorClass(stats.itemsWithMultipleRuns > 0 ? stats.totalConsistencySum / stats.itemsWithMultipleRuns : 0)}">${formatPercent(stats.itemsWithMultipleRuns > 0 ? stats.totalConsistencySum / stats.itemsWithMultipleRuns : 0)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Reliability ${infoIcon(tooltips.reliability)}</div>
              <div class="stat-main ${scoreColorClass(stats.itemsWithAtLeastOnePass > 0 ? stats.totalReliabilitySum / stats.itemsWithAtLeastOnePass : 0)}">${formatPercent(stats.itemsWithAtLeastOnePass > 0 ? stats.totalReliabilitySum / stats.itemsWithAtLeastOnePass : 0)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Score ${infoIcon(tooltips.avgScore)}</div>
              <div class="stat-main ${scoreColorClass(stats.overallAvgScore)}">${formatPercent(stats.overallAvgScore)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Latency ${infoIcon(tooltips.avgLatency)}</div>
              <div class="stat-main">${formatLatency(stats.overallAvgLatency)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Errors ${infoIcon(tooltips.failedCount)}</div>
              <div class="stat-main ${stats.failedCount > 0 ? 'score-1' : ''}">${stats.failedCount}</div>
            </div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Winner Breakdown ${infoIcon(tooltips.winnerBreakdown)}</div>
            <div class="win-loss-bar">
              ${winBarSegments}
              ${tieSegment}
            </div>
            <div class="win-loss-legend">
              ${legendItems}
              ${tieLegend}
            </div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Correct Distribution ${infoIcon(tooltips.correctDist)}</div>
            <div class="distribution-bar">
              ${buildDistributionBar(stats)}
            </div>
          </div>
        `;
      }

      function renderSummaries() {
        const container = el('run-summaries');
        container.innerHTML = state.runs.map((run, idx) => {
          const info = run.run || {};
          const snap = run.snapshot || {};
          const stats = snap.stats || {};
          const color = COLORS[idx % COLORS.length];
          const successRate = (stats.completed || 0) / (stats.total || 1);
          const successClass = getSuccessClass(successRate);
          const isPublished = false;

          const canRemove = state.runs.length > 2;
          return `
            <div class="run-summary-card">
              <div class="run-header">
                <div class="run-color-dot" style="background: ${color}"></div>
                <div class="run-name">${info.run_name || 'Run ' + (idx + 1)}</div>
                ${canRemove ? `<button class="remove-run" data-idx="${idx}" title="Remove from comparison">✕</button>` : ''}
              </div>
              <div class="run-meta">
                <span class="tag task">${info.dataset_name || '—'}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Total Items</span>
                <span class="stat-val">${stats.total || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Completed</span>
                <span class="stat-val">${stats.completed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Failed</span>
                <span class="stat-val ${stats.failed > 0 ? 'low' : ''}">${stats.failed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Success Rate</span>
                <span class="stat-val ${successClass}">${formatPercent(successRate)}</span>
              </div>
            </div>
          `;
        }).join('');

        // Add click handlers for remove buttons
        container.querySelectorAll('.remove-run').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.target.dataset.idx, 10);
            removeRun(idx);
          });
        });
      }

      function renderMetricsTable() {
        const thead = el('metrics-thead');
        const tbody = el('metrics-tbody');

        // Header row
        thead.innerHTML = `
          <tr>
            <th>Metric</th>
            ${state.runs.map((run, idx) => {
              const info = run.run || {};
              const color = COLORS[idx % COLORS.length];
              return `<th><span style="display:inline-block;width:10px;height:10px;background:${color};border-radius:2px;margin-right:6px;"></span>${info.run_name || 'Run ' + (idx + 1)}</th>`;
            }).join('')}
          </tr>
        `;

        // Calculate metric averages and latency for each run
        const runMetricAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricNames = snap.metric_names || run.run?.metric_names || [];
          const avgs = {};

          for (const metric of state.allMetrics) {
            const idx = metricNames.indexOf(metric);
            if (idx === -1) {
              avgs[metric] = null;
              continue;
            }

            let sum = 0, count = 0;
            for (const row of rows) {
              // Use centralized error handling - errors count as 0
              const { score } = window.QymMetrics.getRowScore(row, idx);
              if (score !== null) {
                sum += score;
                count++;
              }
            }
            avgs[metric] = count > 0 ? sum / count : null;
          }
          return avgs;
        });

        // Calculate average latency for each run
        const runLatencyAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          let sum = 0, count = 0;
          for (const row of rows) {
            if (row.latency_ms && row.status === 'completed') {
              sum += row.latency_ms;
              count++;
            }
          }
          return count > 0 ? sum / count : null;
        });

        // Find best (lowest) latency
        const bestLatency = Math.min(...runLatencyAvgs.filter(v => v !== null));

        // Find best value for each metric
        const bestValues = {};
        for (const metric of state.allMetrics) {
          let best = -Infinity;
          for (const avgs of runMetricAvgs) {
            if (avgs[metric] !== null && avgs[metric] > best) {
              best = avgs[metric];
            }
          }
          bestValues[metric] = best > -Infinity ? best : null;
        }

        // Render rows - metrics first, then latency
        const metricRows = state.allMetrics.map(metric => {
          const cells = runMetricAvgs.map(avgs => {
            const val = avgs[metric];
            if (val === null) return '<td class="metric-val">—</td>';
            const isBest = val === bestValues[metric] && state.runs.length > 1;
            const cls = getSuccessClass(val);
            return `<td class="metric-val ${cls} ${isBest ? 'best' : ''}">${formatPercent(val)}</td>`;
          }).join('');

          return `
            <tr>
              <td class="metric-name">${metric}</td>
              ${cells}
            </tr>
          `;
        }).join('');

        // Latency row
        const latencyCells = runLatencyAvgs.map(val => {
          if (val === null) return '<td class="metric-val">—</td>';
          const isBest = val === bestLatency && state.runs.length > 1;
          return `<td class="metric-val ${isBest ? 'best' : ''}" style="${isBest ? 'background: var(--success-dim);' : ''}">${formatLatency(val)}</td>`;
        }).join('');

        const latencyRow = `
          <tr>
            <td class="metric-name">Avg Latency</td>
            ${latencyCells}
          </tr>
        `;

        tbody.innerHTML = metricRows + latencyRow;
      }

      function getFilteredItems() {
        // Build aligned item list across runs using item_id
        const items = [];
        const selectedMetric = state.selectedItemsMetric;
        const stats = selectedMetric ? state.comparisonStats[selectedMetric] : null;

        // Collect all unique item_ids across all runs for proper alignment
        const allItemIds = new Set();
        for (const run of state.runs) {
          const rows = run.snapshot?.rows || [];
          for (const row of rows) {
            const itemId = row.item_id || String(row.index);
            allItemIds.add(itemId);
          }
        }
        const itemIdList = Array.from(allItemIds);

        // Helper to get metric index for a run
        function getMetricIndex(run) {
          const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
          return selectedMetric ? metricNames.indexOf(selectedMetric) : 0;
        }

        for (const itemId of itemIdList) {
          const rowData = state.runs.map(run => {
            const rows = run.snapshot?.rows || [];
            // Match by item_id, fallback to index for legacy data
            return rows.find(r => (r.item_id || String(r.index)) === itemId) || null;
          });

          // Get scores for this item based on selected metric (use centralized error handling)
          const scores = rowData.map((row, runIdx) => {
            if (!row) return null;
            const run = state.runs[runIdx];
            const metricIdx = getMetricIndex(run);
            if (metricIdx < 0) return null;
            // Use centralized error handling from metrics.js
            const { score } = window.QymMetrics.getRowScore(row, metricIdx);
            return score;
          });
          const validScores = scores.filter(s => s !== null);

          // Apply item filter
          if (state.itemFilter === 'different') {
            const outputs = rowData.map(r => r?.output_full || r?.output || '').filter(o => o);
            const uniqueOutputs = new Set(outputs);
            if (uniqueOutputs.size <= 1) continue;
          } else if (state.itemFilter === 'errors') {
            const hasError = rowData.some(r => window.QymMetrics.isErrorRow(r));
            if (!hasError) continue;
          } else if (state.itemFilter === 'all_correct') {
            // All runs meet threshold (correct)
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            if (validScores.length < 2 || !validScores.every(s => s >= correctThreshold)) continue;
          } else if (state.itemFilter === 'all_wrong') {
            // No run meets threshold (not correct)
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            if (validScores.length < 2 || validScores.some(s => s >= correctThreshold)) continue;
          } else if (state.itemFilter === 'rarely_solved') {
            // 25% or fewer runs meet threshold
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            const numCorrect = scores.filter(s => s !== null && s >= correctThreshold).length;
            const rareThreshold = Math.max(1, Math.floor(state.runs.length * 0.25));
            if (numCorrect === 0 || numCorrect > rareThreshold) continue;
          } else if (state.itemFilter === 'unique_solve') {
            // Exactly 1 run meets threshold
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            const numCorrect = scores.filter(s => s !== null && s >= correctThreshold).length;
            if (numCorrect !== 1) continue;
          }

          // Apply winner filter using item_id to index mapping
          if (state.winnerFilter !== 'any' && stats && state.itemIdToIndex) {
            const itemIndex = state.itemIdToIndex[itemId];
            const winner = itemIndex !== undefined ? stats.itemWinners[itemIndex] : null;
            if (state.winnerFilter === 'tie') {
              // Only show ties (all runs same score OR multiple tied for highest)
              if (winner !== 'tie') continue;
            } else if (state.winnerFilter.startsWith('win_')) {
              const winnerIdx = parseInt(state.winnerFilter.replace('win_', ''), 10);
              // Only show items where this run was the SOLE winner (beat all others)
              if (winner !== winnerIdx) continue;
            } else if (state.winnerFilter.startsWith('only_')) {
              // Only show items where ONLY this run met threshold
              const runIdx = parseInt(state.winnerFilter.replace('only_', ''), 10);
              const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
              const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
              const correctRuns = scores.map((s, idx) => s !== null && s >= correctThreshold ? idx : -1).filter(x => x >= 0);
              if (correctRuns.length !== 1 || correctRuns[0] !== runIdx) continue;
            }
          }

          items.push({ itemId: itemId, rowData });
        }

        return items;
      }

      function renderItems(scrollToTop = false) {
        const container = el('items-grid');
        const paginationEl = el('pagination');
        const filterCountEl = el('filter-count');
        const items = getFilteredItems();

        // Update filter count display
        filterCountEl.innerHTML = `<span class="count-num">${items.length}</span> items`;

        // Set CSS variable for grid columns
        container.style.setProperty('--run-count', state.runs.length);

        // Pagination
        const totalPages = Math.max(1, Math.ceil(items.length / state.pageSize));
        if (state.page > totalPages) state.page = totalPages;
        const start = (state.page - 1) * state.pageSize;
        const pageItems = items.slice(start, start + state.pageSize);

        if (items.length === 0) {
          container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);">No items match the current filter</div>';
          paginationEl.innerHTML = '';
          return;
        }

        container.innerHTML = pageItems.map(({ itemId, rowData }) => {
          // Get input and expected from any available row
          const inputRow = rowData.find(r => r);
          const input = inputRow?.input_full || inputRow?.input || '—';
          const expected = inputRow?.expected_full || inputRow?.expected || '';

          // Use a safe ID for DOM elements by encoding the itemId
          const safeId = btoa(itemId).replace(/[+/=]/g, '_');

          const outputCells = rowData.map((row, runIdx) => {
            const color = COLORS[runIdx % COLORS.length];
            const runInfo = state.runs[runIdx]?.run || {};

            if (!row) {
              return `
                <div class="item-run-output" style="border-left-color: ${color}">
                  <div class="output-header">
                    <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)}</span>
                  </div>
                  <div class="output-text" style="color:var(--text-muted);font-style:italic;">No data</div>
                </div>
              `;
            }

            const output = row.output_full || row.output || '—';
            const status = row.status || 'pending';
            const latencyMs = row.latency_ms;
            const taskStartedAtMs = row.task_started_at_ms;
            const traceId = row.trace_id;
            // Use direct trace_url if available, otherwise build from trace_id (global or per-run config)
            const traceUrl = row.trace_url || buildLangfuseTraceUrl(traceId) || buildLangfuseTraceUrlFromRun(traceId, runInfo);

            // Get metric values and metadata
            const metricVals = row.metric_values || [];
            const metricMeta = row.metric_meta || {};
            const run = state.runs[runIdx];
            const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];

            // Determine if this run is the winner for the selected metric
            const selectedMetric = state.selectedItemsMetric;
            const stats = selectedMetric ? state.comparisonStats[selectedMetric] : null;
            // Use itemIdToIndex mapping to find the winner for this item
            const itemIndex = state.itemIdToIndex?.[itemId];
            const itemWinner = itemIndex !== undefined ? stats?.itemWinners?.[itemIndex] : null;
            const isWinner = itemWinner === runIdx;

            // Build inline metric scores (all metrics shown, selected one highlighted)
            const metricScoresHtml = metricNames.map((name, i) => {
              const score = metricVals[i];
              const v = parseFloat(score);
              if (isNaN(v)) return '';

              const cls = getSuccessClass(v);
              const isSelected = name === selectedMetric;
              const meta = metricMeta[name] || {};
              const editBtn = `<button class="metric-edit-open" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}" aria-label="Edit ${escapeAttr(name)}" title="Edit">✎</button>`;
              const editedBadge = String(meta.modified || '').toLowerCase() === 'true'
                ? '<span class="metric-edit-badge">Edited</span>'
                : '';

              return `<div class="metric-score-row ${isSelected ? 'highlighted' : ''}">
                <span class="metric-score-name">${escapeHtml(name)}</span>
                <span class="metric-score-meta">
                  <span class="metric-score-value ${cls}">${formatPercent(v)}</span>
                  ${editBtn}
                  ${editedBadge}
                </span>
              </div>`;
            }).join('');

            let metricEditHtml = '';
            if (metricNames.length) {
              metricEditHtml = metricNames.map((name, i) => {
                const rawScore = metricVals[i];
                const rawValue = (rawScore == null || rawScore === '') ? '' : String(rawScore);
                const meta = metricMeta[name] || {};
                const originalRaw = meta.original_score;
                const hasOriginal = !(originalRaw == null || originalRaw === '');
                const modifiedNote = hasOriginal
                  ? `<div class="metric-edit-meta">Original: ${escapeHtml(String(originalRaw))}</div>`
                  : '';
                return `
                  <div class="metric-edit-block hidden" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}">
                    <div class="metric-edit-title">Edit ${escapeHtml(name)}_score</div>
                    <div class="metric-edit-controls">
                      <input class="metric-edit-input" type="text" value="${escapeAttr(rawValue)}" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}" />
                      <button class="metric-edit-save" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}">Save</button>
                      <span class="metric-edit-status" aria-live="polite"></span>
                    </div>
                    ${modifiedNote}
                  </div>
                `;
              }).join('');
            }

            // Latency badge
            const latencyBadge = latencyMs ? `<span class="latency-badge">${formatLatency(latencyMs)}</span>` : '';

            // Task start badge (local time)
            const startInfo = formatTaskStart(taskStartedAtMs);
            const startBadge = startInfo
              ? `<span class="start-badge" title="${escapeAttr(startInfo.ts)}">${escapeHtml(startInfo.ts)}</span>`
              : '';

            // Langfuse trace link
            const traceLink = traceUrl ? `<a href="${traceUrl}" target="_blank" class="trace-link" title="View trace in Langfuse">Langfuse ↗</a>` : '';

            // Build metric details for this run (hidden by default, controlled by shared toggle)
            let metricDetailsHtml = '';
            const hasMetricMeta = Object.keys(metricMeta).length > 0;

            if (hasMetricMeta) {
              const detailRows = metricNames.map((name) => {
                const meta = metricMeta[name] || {};
                const metaKeys = Object.keys(meta).filter(k => !['modified','original_score'].includes(k));
                if (metaKeys.length === 0) return '';

                return metaKeys.map(key => {
                  const val = meta[key];
                  if (val === undefined || val === null || val === '') return '';
                  const displayName = formatFieldName(key);
                  return `<div class="metric-detail-row">
                    <span class="metric-detail-name">${escapeHtml(name)} · ${displayName}</span>
                    <span class="metric-detail-value">${escapeHtml(String(val))}</span>
                  </div>`;
                }).join('');
              }).join('');

              if (detailRows) {
                metricDetailsHtml = `
                  <div class="run-metric-details" data-item="${safeId}">
                    ${detailRows}
                  </div>
                `;
              }
            }

            const winnerBadge = isWinner ? '<span class="winner-badge">★ Winner</span>' : '';
            return `
              <div class="item-run-output" style="border-left-color: ${color}">
                <div class="output-header">
                  <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)} ${winnerBadge}</span>
                  <span class="output-badges">${startBadge}${latencyBadge}${traceLink}</span>
                </div>
                <div class="output-text ${status === 'error' ? 'low' : ''}">${formatValue(output)}</div>
                <div class="metric-scores-inline">${metricScoresHtml}</div>
                ${metricEditHtml}
                ${metricDetailsHtml}
              </div>
            `;
          }).join('');

          // Only show expected row if there's expected output
          const expectedRow = expected ? `
              <div class="item-expected-row">
                <div class="expected-label">Expected Output</div>
                <div class="expected-text">${formatValue(expected)}</div>
              </div>
          ` : '';

          // Build shared metric details section (all runs' metadata in one expandable area)
          const metricDetailsHtml = buildMetricDetailsSection(itemId, rowData);

          // Format item ID for display (e.g., "item_5" -> "Item 6", or keep original if not matching pattern)
          let displayItemId = itemId;
          const itemMatch = itemId.match(/^item_(\d+)$/);
          if (itemMatch) {
            displayItemId = `Item ${parseInt(itemMatch[1], 10) + 1}`;
          }

          return `
            <div class="item-comparison-row">
              <div class="item-header">
                <span class="item-index" title="ID: ${escapeHtml(itemId)}">${escapeHtml(displayItemId)}</span>
              </div>
              <div class="item-input-row">
                <div class="input-label">Input</div>
                <div class="input-text">${formatValue(input)}</div>
              </div>
              ${expectedRow}
              <div class="item-outputs-row" style="--run-count: ${state.runs.length}">
                ${outputCells}
              </div>
              ${metricDetailsHtml}
            </div>
          `;
        }).join('');

        // Pagination controls
        paginationEl.innerHTML = `
          <button id="prev-page" ${state.page <= 1 ? 'disabled' : ''}>← Prev</button>
          <span class="page-info">Page ${state.page} of ${totalPages}</span>
          <button id="next-page" ${state.page >= totalPages ? 'disabled' : ''}>Next →</button>
        `;

        el('prev-page').onclick = () => { state.page--; renderItems(true); };
        el('next-page').onclick = () => { state.page++; renderItems(true); };

        // Scroll to top of items grid if requested
        if (scrollToTop) {
          container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        wireMetricEditHandlers();
        alignOutputHeights();
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
      }
      function escapeAttr(text) {
        return String(text ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function alignOutputHeights() {
        try {
          const rows = document.querySelectorAll('.item-outputs-row');
          rows.forEach(row => {
            const outputs = row.querySelectorAll('.item-run-output .output-text');
            if (!outputs.length) return;
            outputs.forEach(el => { el.style.minHeight = '0px'; });
            let max = 0;
            outputs.forEach(el => {
              const h = el.scrollHeight || el.offsetHeight || 0;
              if (h > max) max = h;
            });
            outputs.forEach(el => { el.style.minHeight = `${max}px`; });
          });
        } catch {}
      }

      async function updateMetricScore(filePath, rowIndex, metricName, newScore) {
        const res = await fetch(apiUrl('api/runs/update_metric'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            file_path: filePath,
            row_index: rowIndex,
            metric_name: metricName,
            new_score: newScore,
          }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.error) {
          throw new Error(data.error || 'Failed to update metric');
        }
        return data;
      }

      function applyUpdatedRowToRun(runIdx, updatedRow) {
        try {
          const run = state.runs[runIdx];
          if (!run || !run.snapshot) return;
          const rows = run.snapshot.rows || [];
          const idx = Number(updatedRow.index) || 0;
          if (idx >= 0 && idx < rows.length) {
            rows[idx] = updatedRow;
          } else {
            const pos = rows.findIndex(r => Number(r.index) === idx);
            if (pos >= 0) rows[pos] = updatedRow;
          }
        } catch {}
      }

      function refreshComparisonStatsAfterEdit() {
        // Recalculate stats for ALL metrics (the edit may affect any of them)
        for (const metricName of state.allMetrics) {
          state.comparisonStats[metricName] = calculateComparisonStatsForMetric(metricName);
        }
        renderComparisonStats();
        renderMetricsTable();
        renderSummaries();
      }

      function wireMetricEditHandlers() {
        document.querySelectorAll('.metric-edit-open').forEach(btn => {
          btn.onclick = () => {
            const runIdx = btn.dataset.runIdx;
            const rowIndex = btn.dataset.rowIndex;
            const metric = btn.dataset.metric;
            const block = document.querySelector(`.metric-edit-block[data-run-idx="${runIdx}"][data-row-index="${rowIndex}"][data-metric="${metric}"]`);
            if (!block) return;
            const isHidden = block.classList.contains('hidden');
            block.classList.toggle('hidden');
            btn.textContent = isHidden ? '✕' : '✎';
            btn.setAttribute('title', isHidden ? 'Close' : 'Edit');
            btn.setAttribute('aria-label', isHidden ? 'Close edit' : 'Edit');
          };
        });
        document.querySelectorAll('.metric-edit-save').forEach(btn => {
          btn.onclick = async () => {
            const runIdx = Number(btn.dataset.runIdx);
            const rowIndex = Number(btn.dataset.rowIndex);
            const metricName = btn.dataset.metric || '';
            const controls = btn.closest('.metric-edit-controls');
            const input = controls ? controls.querySelector('.metric-edit-input') : null;
            const status = controls ? controls.querySelector('.metric-edit-status') : null;
            const run = state.runs[runIdx];
            const filePath = run?.run?.file_path || '';
            if (!filePath || !metricName || !input) {
              if (status) status.textContent = 'Unavailable';
              return;
            }
            btn.disabled = true;
            if (status) status.textContent = 'Saving...';
            try {
              const result = await updateMetricScore(filePath, rowIndex, metricName, input.value);
              if (result && result.row) {
                applyUpdatedRowToRun(runIdx, result.row);
                refreshComparisonStatsAfterEdit();
                renderItems();
              }
            } catch (err) {
              if (status) status.textContent = 'Error';
            } finally {
              btn.disabled = false;
              if (status && status.textContent === 'Saving...') status.textContent = '';
            }
          };
        });
      }

      // Global function for toggling all metric details for an item
      window.toggleItemMetricDetails = function(itemIndex) {
        const details = document.querySelectorAll(`.run-metric-details[data-item="${itemIndex}"]`);
        const icon = document.getElementById(`toggle-icon-${itemIndex}`);

        if (details.length === 0) return;

        const isExpanded = details[0].classList.contains('expanded');

        details.forEach(detail => {
          if (isExpanded) {
            detail.classList.remove('expanded');
          } else {
            detail.classList.add('expanded');
          }
        });

        if (icon) {
          icon.textContent = isExpanded ? '▶' : '▼';
        }
      };

      // Format field names to be more readable
      function formatFieldName(name) {
        // Remove common prefixes and convert to title case
        return name
          .replace(/_/g, ' ')
          .replace(/\b\w/g, c => c.toUpperCase());
      }

      // Build shared toggle button for metric details (controls all runs' details for this item)
      function buildMetricDetailsSection(itemId, rowData) {
        // Check if any run has metadata
        const hasAnyMeta = rowData.some(row => {
          if (!row) return false;
          const metricMeta = row.metric_meta || {};
          return Object.keys(metricMeta).some(metric => {
            const meta = metricMeta[metric] || {};
            return Object.keys(meta).length > 0;
          });
        });

        if (!hasAnyMeta) return '';

        // Use a safe ID for DOM elements by encoding the itemId
        const safeId = btoa(itemId).replace(/[+/=]/g, '_');

        return `
          <div class="item-metric-details-toggle">
            <button class="metric-details-toggle" onclick="toggleItemMetricDetails('${safeId}')">
              <span class="toggle-icon" id="toggle-icon-${safeId}">▶</span> Metric Details
            </button>
          </div>
        `;
      }

      function formatValue(value) {
        // Handle null/undefined
        if (value === null || value === undefined) {
          return '—';
        }

        // If it's already a string, check if it's a JSON string or Python dict repr
        if (typeof value === 'string') {
          const trimmed = value.trim();

          // Try to parse as JSON first
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'object' && parsed !== null) {
              return formatObjectAsHtml(parsed);
            }
          } catch {
            // Not valid JSON, continue to try Python dict repr
          }

          // Try to handle Python dict repr (single quotes, True/False/None)
          if ((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
              (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
            const parsed = parsePythonDict(trimmed);
            if (parsed !== null) {
              return formatObjectAsHtml(parsed);
            }
          }

          return escapeHtml(value);
        }

        // If it's an object or array, format it nicely
        if (typeof value === 'object') {
          return formatObjectAsHtml(value);
        }

        // For other primitives, just convert to string
        return escapeHtml(String(value));
      }

      function parsePythonDict(str) {
        // Parse Python dict repr like {'key': 'value', 'num': 123, 'bool': True}
        // This is a simple parser that handles common cases
        try {
          let i = 0;
          const len = str.length;

          function skipWhitespace() {
            while (i < len && /\s/.test(str[i])) i++;
          }

          function parseValue() {
            skipWhitespace();
            if (i >= len) return undefined;

            const ch = str[i];

            // String (single or double quoted)
            if (ch === "'" || ch === '"') {
              return parseString(ch);
            }
            // Object
            if (ch === '{') {
              return parseObject();
            }
            // Array
            if (ch === '[') {
              return parseArray();
            }
            // Number, boolean, None
            return parseLiteral();
          }

          function parseString(quote) {
            i++; // skip opening quote
            let result = '';
            while (i < len) {
              const ch = str[i];
              if (ch === '\\' && i + 1 < len) {
                // Handle escape sequences
                const next = str[i + 1];
                if (next === 'n') { result += '\n'; i += 2; }
                else if (next === 't') { result += '\t'; i += 2; }
                else if (next === 'r') { result += '\r'; i += 2; }
                else if (next === '\\') { result += '\\'; i += 2; }
                else if (next === quote) { result += quote; i += 2; }
                else { result += ch; i++; }
              } else if (ch === quote) {
                i++; // skip closing quote
                return result;
              } else {
                result += ch;
                i++;
              }
            }
            return result; // unclosed string
          }

          function parseObject() {
            i++; // skip '{'
            const obj = {};
            skipWhitespace();
            if (str[i] === '}') { i++; return obj; }

            while (i < len) {
              skipWhitespace();
              // Parse key (must be string)
              const key = parseValue();
              if (typeof key !== 'string') return null;

              skipWhitespace();
              if (str[i] !== ':') return null;
              i++; // skip ':'

              // Parse value
              const val = parseValue();
              obj[key] = val;

              skipWhitespace();
              if (str[i] === '}') { i++; return obj; }
              if (str[i] === ',') { i++; continue; }
              return null; // unexpected character
            }
            return obj;
          }

          function parseArray() {
            i++; // skip '['
            const arr = [];
            skipWhitespace();
            if (str[i] === ']') { i++; return arr; }

            while (i < len) {
              const val = parseValue();
              arr.push(val);

              skipWhitespace();
              if (str[i] === ']') { i++; return arr; }
              if (str[i] === ',') { i++; continue; }
              return null;
            }
            return arr;
          }

          function parseLiteral() {
            // Check for True, False, None, or numbers
            if (str.slice(i, i + 4) === 'True') { i += 4; return true; }
            if (str.slice(i, i + 5) === 'False') { i += 5; return false; }
            if (str.slice(i, i + 4) === 'None') { i += 4; return null; }

            // Parse number
            let numStr = '';
            while (i < len && /[0-9.\-+eE]/.test(str[i])) {
              numStr += str[i];
              i++;
            }
            if (numStr) {
              const num = parseFloat(numStr);
              if (!isNaN(num)) return num;
            }
            return undefined;
          }

          const result = parseValue();
          return result;
        } catch {
          return null;
        }
      }

      function formatObjectAsHtml(obj) {
        if (Array.isArray(obj)) {
          // Format arrays
          if (obj.length === 0) return '<span class="formatted-array">[]</span>';
          const items = obj.map((item, idx) => {
            let formattedItem;
            if (item === null || item === undefined) {
              formattedItem = '<span class="formatted-null">null</span>';
            } else if (typeof item === 'object') {
              formattedItem = formatObjectAsHtml(item);
            } else if (typeof item === 'string') {
              formattedItem = `<span class="formatted-string">${escapeHtml(item)}</span>`;
            } else {
              formattedItem = escapeHtml(String(item));
            }
            return `<div class="formatted-array-item"><span class="formatted-index">[${idx}]</span> ${formattedItem}</div>`;
          }).join('');
          return `<div class="formatted-array">${items}</div>`;
        }

        // Format objects as key-value pairs
        const entries = Object.entries(obj);
        if (entries.length === 0) return '<span class="formatted-object">{}</span>';

        const rows = entries.map(([key, val]) => {
          let formattedVal;
          if (val === null || val === undefined) {
            formattedVal = '<span class="formatted-null">null</span>';
          } else if (typeof val === 'object') {
            formattedVal = formatObjectAsHtml(val);
          } else if (typeof val === 'string') {
            // Show full string without quotes
            formattedVal = `<span class="formatted-string">${escapeHtml(val)}</span>`;
          } else if (typeof val === 'number') {
            formattedVal = `<span class="formatted-number">${val}</span>`;
          } else if (typeof val === 'boolean') {
            formattedVal = `<span class="formatted-boolean">${val}</span>`;
          } else {
            formattedVal = escapeHtml(String(val));
          }
          return `<div class="formatted-row"><span class="formatted-key">${escapeHtml(key)}</span>${formattedVal}</div>`;
        }).join('');

        return `<div class="formatted-object">${rows}</div>`;
      }

      // Event listeners
      el('item-filter').addEventListener('change', (e) => {
        state.itemFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      el('run-winner-filter').addEventListener('change', (e) => {
        state.winnerFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      // Initialize
      loadComparisonData();
    })();
  </script>
</body>
</html>
