<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>قيِّم • Compare Runs</title>
  <link rel="icon" type="image/png" href="./static/qym_icon.png">
  <link rel="stylesheet" href="./static/dashboard.css">
  <script src="./static/metrics.js"></script>
  <style>
    /* Compare-specific styles */
    .compare-container {
      padding: var(--space-lg);
      overflow-y: auto;
      height: calc(100vh - 100px);
    }

    .compare-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-md);
      border-bottom: 1px solid var(--border-default);
    }

    .compare-title {
      font-size: var(--font-lg);
      font-weight: 600;
      color: var(--text-primary);
    }

    .compare-subtitle {
      font-size: var(--font-sm);
      color: var(--text-muted);
      margin-top: 4px;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      color: var(--accent-primary);
      text-decoration: none;
      font-size: var(--font-sm);
    }

    .back-link:hover {
      text-decoration: underline;
    }

    /* Summary cards grid */
    .compare-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-md);
      margin-bottom: var(--space-xl);
    }

    .run-summary-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
    }

    .run-summary-card .run-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .remove-run {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: var(--font-sm);
    }

    .run-summary-card .remove-run:hover {
      background: var(--error-dim);
      color: var(--error);
    }

    .run-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .run-summary-card .run-name {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      color: var(--text-primary);
      word-break: break-all;
    }


    .run-summary-card .run-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .stats-row {
      display: flex;
      justify-content: space-between;
      padding: var(--space-xs) 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .run-summary-card .stats-row:last-child {
      border-bottom: none;
    }

    .run-summary-card .stat-label {
      color: var(--text-muted);
      font-size: var(--font-sm);
    }

    .run-summary-card .stat-val {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-primary);
    }

    .run-summary-card .stat-val.score-5 { color: var(--score-5); }
    .run-summary-card .stat-val.score-4 { color: var(--score-4); }
    .run-summary-card .stat-val.score-3 { color: var(--score-3); }
    .run-summary-card .stat-val.score-2 { color: var(--score-2); }
    .run-summary-card .stat-val.score-1 { color: var(--score-1); }

    /* Comparison Stats Section */
    .comparison-stats {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
      margin-bottom: var(--space-xl);
    }

    .section-title {
      font-size: var(--font-lg);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .stats-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .stats-row {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
    }

    .stat-box {
      background: var(--bg-elevated);
      border-radius: 6px;
      padding: var(--space-sm) var(--space-md);
      flex: 1;
      min-width: 120px;
    }

    .stat-box.wide {
      flex: 100%;
      padding: var(--space-md);
    }

    .stat-box .stat-title {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .stat-info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background: var(--accent-primary);
      color: var(--bg-primary);
      font-size: 10px;
      font-weight: 700;
      font-style: italic;
      font-family: Georgia, serif;
      cursor: help;
      position: relative;
      text-transform: lowercase;
      flex-shrink: 0;
    }

    .stat-info-icon:hover {
      background: var(--text-primary);
      color: var(--bg-primary);
      transform: scale(1.1);
    }

    .stat-info-tooltip {
      display: none;
      position: absolute;
      bottom: calc(100% + 8px);
      left: 0;
      background: var(--bg-elevated);
      border: 1px solid var(--border-default);
      border-radius: 6px;
      padding: 10px 12px;
      width: 240px;
      font-size: var(--font-sm);
      font-weight: 400;
      font-style: normal;
      font-family: var(--font-sans);
      color: var(--text-secondary);
      text-transform: none;
      letter-spacing: normal;
      line-height: 1.5;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: left;
    }

    .stat-info-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 12px;
      border: 6px solid transparent;
      border-top-color: var(--border-default);
    }

    .stat-info-icon:hover .stat-info-tooltip {
      display: block;
    }

    .stat-box .stat-main {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
    }

    .stat-box.wide .stat-main {
      font-size: var(--font-lg);
    }

    .stat-box .stat-main.score-5 { color: var(--score-5); }
    .stat-box .stat-main.score-4 { color: var(--score-4); }
    .stat-box .stat-main.score-3 { color: var(--score-3); }
    .stat-box .stat-main.score-2 { color: var(--score-2); }
    .stat-box .stat-main.score-1 { color: var(--score-1); }

    .stat-box .stat-detail {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* ── Metadata Breakdown cards ── */
    .breakdown-section {
      margin-bottom: var(--space-lg);
    }

    .breakdown-header {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-sm);
    }

    .breakdown-icon {
      font-size: var(--font-sm);
      line-height: 1;
    }

    .breakdown-complexity .breakdown-icon,
    .breakdown-complexity .breakdown-header {
      color: #fb923c;
    }

    .breakdown-domain .breakdown-icon,
    .breakdown-domain .breakdown-header {
      color: #60a5fa;
    }

    .breakdown-metric {
      font-size: var(--font-xs);
      font-family: var(--font-mono);
      color: var(--text-muted);
      font-weight: 400;
      padding: 1px 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      margin-left: 4px;
    }

    .breakdown-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: var(--space-sm);
    }

    .breakdown-card {
      background: var(--bg-elevated);
      border-radius: 6px;
      padding: var(--space-sm) var(--space-md);
      display: flex;
      flex-direction: column;
      gap: 3px;
      border: 1px solid var(--border-subtle);
      transition: border-color 0.15s;
    }

    .breakdown-card:hover {
      border-color: var(--border-default);
    }

    .breakdown-complexity .breakdown-card {
      border-left: 3px solid rgba(249, 115, 22, 0.3);
    }
    .breakdown-complexity .breakdown-card.complexity-easy {
      border-left-color: rgba(34, 197, 94, 0.5);
    }
    .breakdown-complexity .breakdown-card.complexity-easy .breakdown-card-label {
      color: #4ade80;
    }
    .breakdown-complexity .breakdown-card.complexity-medium {
      border-left-color: rgba(234, 179, 8, 0.5);
    }
    .breakdown-complexity .breakdown-card.complexity-medium .breakdown-card-label {
      color: #facc15;
    }
    .breakdown-complexity .breakdown-card.complexity-hard {
      border-left-color: rgba(239, 68, 68, 0.5);
    }
    .breakdown-complexity .breakdown-card.complexity-hard .breakdown-card-label {
      color: #f87171;
    }
    .breakdown-complexity .breakdown-card.complexity-expert {
      border-left-color: rgba(168, 85, 247, 0.5);
    }
    .breakdown-complexity .breakdown-card.complexity-expert .breakdown-card-label {
      color: #c084fc;
    }

    .breakdown-domain .breakdown-card {
      border-left: 3px solid rgba(96, 165, 250, 0.3);
    }

    .breakdown-card-top {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: var(--space-sm);
    }

    .breakdown-card-label {
      font-size: var(--font-sm);
      font-weight: 600;
      color: var(--text-primary);
      text-transform: capitalize;
    }

    .breakdown-card-count {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 10px;
      font-family: var(--font-mono);
      color: var(--text-muted);
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: 100px;
      padding: 1px 8px;
      flex-shrink: 0;
      letter-spacing: 0.3px;
    }
    .breakdown-card-count strong {
      color: var(--text-secondary);
      font-weight: 600;
    }

    .breakdown-card-score {
      font-family: var(--font-mono);
      font-size: var(--font-lg);
      font-weight: 700;
    }

    .breakdown-card-score.score-5 { color: var(--score-5); }
    .breakdown-card-score.score-4 { color: var(--score-4); }
    .breakdown-card-score.score-3 { color: var(--score-3); }
    .breakdown-card-score.score-2 { color: var(--score-2); }
    .breakdown-card-score.score-1 { color: var(--score-1); }

    .breakdown-card-details {
      display: flex;
      gap: var(--space-md);
      margin-top: 2px;
    }

    .breakdown-detail {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      color: var(--text-secondary);
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .breakdown-detail-label {
      font-family: var(--font-sans);
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.4px;
      font-weight: 500;
    }

    /* Win/Loss bars */
    .win-loss-bar {
      display: flex;
      height: 28px;
      border-radius: 4px;
      overflow: hidden;
      margin-top: var(--space-sm);
      gap: 2px;
    }

    .win-loss-bar .segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-xs);
      font-weight: 600;
      color: #fff;
      transition: flex 0.3s;
      min-width: 0;
      padding: 0 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .win-loss-bar .segment.tie {
      background: var(--text-muted);
    }

    .win-loss-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .win-loss-legend .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: var(--font-xs);
      color: var(--text-secondary);
    }

    .win-loss-legend .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .win-loss-legend .legend-count {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    /* Distribution bar */
    .distribution-bar {
      display: flex;
      height: 32px;
      border-radius: 4px;
      overflow: hidden;
      gap: 2px;
      margin-top: var(--space-sm);
    }

    .dist-segment {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 0;
      padding: 2px 4px;
      color: #fff;
      font-size: var(--font-xs);
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .dist-segment .dist-label {
      font-weight: 700;
      font-size: var(--font-sm);
    }

    .dist-segment .dist-count {
      font-size: 10px;
      opacity: 0.9;
    }

    .dist-segment.dist-zero {
      background: var(--error);
    }

    .dist-segment.dist-all {
      background: var(--success);
    }

    .dist-segment.dist-partial {
      background: var(--warning);
    }

    .distribution-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .dist-legend-item {
      display: inline-flex;
      gap: 4px;
    }

    .dist-legend-item strong {
      color: var(--text-secondary);
    }

    /* Metrics comparison table */
    .metrics-comparison {
      margin-bottom: var(--space-xl);
    }

    .metrics-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .metrics-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
    }

    .metrics-table th,
    .metrics-table td {
      padding: var(--space-sm) var(--space-md);
      text-align: left;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metrics-table th:not(:first-child),
    .metrics-table td:not(:first-child) {
      text-align: center;
    }

    .metrics-table thead th {
      background: var(--bg-elevated);
      font-size: var(--font-xs);
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metrics-table tbody td {
      font-size: var(--font-sm);
    }

    .metrics-table .metric-name {
      font-family: var(--font-mono);
      color: var(--text-secondary);
    }

    .metrics-table .metric-val {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    .metrics-table .metric-val.score-5 { color: var(--score-5); }
    .metrics-table .metric-val.score-4 { color: var(--score-4); }
    .metrics-table .metric-val.score-3 { color: var(--score-3); }
    .metrics-table .metric-val.score-2 { color: var(--score-2); }
    .metrics-table .metric-val.score-1 { color: var(--score-1); }

    .metrics-table .metric-val.best {
      background: var(--success-dim);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .metrics-table .diff {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .metrics-table .diff.positive {
      color: var(--success);
    }

    .metrics-table .diff.negative {
      color: var(--error);
    }

    /* Side-by-side items view */
    .items-comparison {
      margin-bottom: var(--space-xl);
    }

    .items-comparison .section-title {
      margin-bottom: var(--space-md);
    }

    /* ── Filter Panel ── */
    .filter-panel {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      margin-bottom: var(--space-lg);
      overflow: visible;
    }

    /* Row 1: Filter dropdowns + actions */
    .fp-filter-row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
    }

    .fp-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
      min-width: 0;
    }

    .fp-label {
      font-size: 9px;
      font-family: var(--font-sans);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
      font-weight: 500;
      line-height: 1;
      padding-left: 1px;
    }

    .fp-group .filter-select {
      min-width: unset;
      max-width: unset;
    }

    .fp-pass-rate-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .fp-pass-rate-input {
      width: 36px;
      padding: var(--space-xs) 4px;
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 3px;
      color: var(--text-primary);
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      text-align: center;
      -moz-appearance: textfield;
    }
    .fp-pass-rate-input::-webkit-outer-spin-button,
    .fp-pass-rate-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .fp-pass-rate-input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px rgba(0, 209, 178, 0.15);
    }
    .fp-pass-rate-suffix {
      font-size: var(--font-xs);
      color: var(--text-muted);
      white-space: nowrap;
    }

    .fp-cat-group {
      min-width: 0;
    }

    .fp-cat-group .multi-select-btn.has-selection {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .fp-cat-group .multi-select-option .option-count {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-left: auto;
    }

    .fp-cat-group .multi-select-dropdown .ms-actions {
      display: flex;
      gap: 4px;
      padding: 4px 8px;
      border-top: 1px solid var(--border-subtle);
    }

    .fp-cat-group .multi-select-dropdown .ms-action-btn {
      flex: 1;
      padding: 4px 0;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: var(--font-xs);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.15s;
    }

    .fp-cat-group .multi-select-dropdown .ms-action-btn:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    /* Gear icon wrapper — aligns with dropdowns without a label */
    .fp-gear-wrapper {
      display: flex;
      align-items: flex-end;
    }

    /* Gear button for metadata fields — overrides .metadata-fields-btn */
    .fp-gear-btn.metadata-fields-btn {
      padding: var(--space-xs) var(--space-sm);
      padding-right: var(--space-sm);
      background: var(--bg-surface);
      background-image: none;
      border: 1px solid var(--border-default);
      border-radius: 3px;
      color: var(--text-muted);
      font-size: var(--font-base);
      cursor: pointer;
      transition: all 0.15s;
      line-height: 1;
    }

    .fp-gear-btn.metadata-fields-btn:hover {
      color: var(--text-primary);
      border-color: var(--border-strong);
      background-color: var(--bg-hover);
    }

    /* Push actions to the right */
    .fp-actions-spacer {
      flex: 1 1 0;
    }

    .fp-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
      align-self: flex-end;
    }

    .fp-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: var(--space-xs) var(--space-sm);
      background: transparent;
      border: 1px solid var(--border-default);
      border-radius: 3px;
      color: var(--text-muted);
      font-size: var(--font-xs);
      font-family: var(--font-sans);
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .fp-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
      border-color: var(--border-strong);
    }

    .fp-clear-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: var(--space-xs) var(--space-sm);
      background: rgba(239, 68, 68, 0.08);
      border: 1px solid rgba(239, 68, 68, 0.2);
      border-radius: 3px;
      color: #f87171;
      font-size: var(--font-xs);
      font-family: var(--font-sans);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
      visibility: hidden;
    }
    .fp-clear-btn.visible {
      visibility: visible;
    }
    .fp-clear-btn:hover {
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.35);
      color: #fca5a5;
    }
    .fp-clear-x {
      font-size: 13px;
      font-weight: 600;
      line-height: 1;
    }
    .fp-clear-count {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 16px;
      height: 16px;
      padding: 0 4px;
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
      border-radius: 8px;
      font-size: 9px;
      font-weight: 700;
      line-height: 1;
    }

    .fp-btn.fp-export {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-void);
      font-size: var(--font-sm);
      font-weight: 500;
    }

    .fp-btn.fp-export:hover {
      background: #00e6b8;
      border-color: #00e6b8;
      color: var(--bg-void);
    }

    /* Row 2: Search */
    .fp-search-row {
      padding: 0 var(--space-md) var(--space-sm);
    }

    .fp-search {
      display: flex;
      align-items: center;
      background: var(--bg-elevated);
      border: 1px solid var(--border-default);
      border-radius: 3px;
      padding: 0 var(--space-sm);
      transition: border-color 0.15s;
    }

    .fp-search:focus-within {
      border-color: var(--accent-primary);
    }

    .fp-search-icon {
      color: var(--text-muted);
      font-size: var(--font-sm);
      flex-shrink: 0;
      margin-right: 6px;
      line-height: 1;
    }

    .fp-search input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      padding: var(--space-xs) 0;
      outline: none;
      min-width: 0;
    }

    .fp-search input::placeholder {
      color: var(--text-muted);
    }

    /* Status bar */
    .fp-status {
      padding: var(--space-xs) var(--space-md);
      border-top: 1px solid var(--border-subtle);
    }

    .fp-status .filter-count {
      font-size: var(--font-xs);
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .fp-status .filter-count .count-num {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .items-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-xl);
    }

    .item-comparison-row {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-md);
    }

    .item-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding-bottom: var(--space-sm);
      border-bottom: 1px solid var(--border-subtle);
    }

    .item-index {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-muted);
    }

    .item-input-row,
    .item-expected-row {
      background: var(--bg-elevated);
      padding: var(--space-sm);
      border-radius: 4px;
    }

    .item-input-row .input-label,
    .item-expected-row .expected-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .item-input-row .input-text,
    .item-expected-row .expected-text {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-secondary);
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .item-expected-row {
      background: var(--success-dim);
      border-left: 3px solid var(--success);
    }

    .item-expected-row .expected-label {
      color: var(--success);
    }

    .item-outputs-row {
      display: grid;
      grid-template-columns: repeat(var(--run-count, 2), 1fr);
      gap: var(--space-sm);
      margin-top: var(--space-sm);
      align-items: start;
    }

    .item-run-output {
      border-left: 3px solid var(--border-default);
      padding-left: var(--space-sm);
      background: var(--bg-elevated);
      border-radius: 0 4px 4px 0;
      padding: var(--space-sm);
    }

    .item-run-output .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
      flex-wrap: wrap;
      gap: 4px;
    }

    .item-run-output .run-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .item-run-output .output-badges {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .item-run-output .metric-badge,
    .item-run-output .latency-badge {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-surface);
    }

    .item-run-output .metric-badge.score-5 { background: var(--success-dim); color: var(--score-5); }
    .item-run-output .metric-badge.score-4 { background: rgba(132, 204, 22, 0.15); color: var(--score-4); }
    .item-run-output .metric-badge.score-3 { background: rgba(234, 179, 8, 0.15); color: var(--score-3); }
    .item-run-output .metric-badge.score-2 { background: rgba(249, 115, 22, 0.15); color: var(--score-2); }
    .item-run-output .metric-badge.score-1 { background: var(--error-dim); color: var(--score-1); }

    .item-run-output .latency-badge {
      color: var(--text-muted);
    }

    .item-run-output .start-badge {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-surface);
      color: var(--text-muted);
    }

    .item-run-output .trace-link {
      display: inline-flex;
      align-items: center;
      padding: 1px 5px;
      background: rgba(225, 29, 72, 0.15);
      color: #e11d48;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
      text-decoration: none;
      transition: background 0.15s;
    }

    .item-run-output .trace-link:hover {
      background: rgba(225, 29, 72, 0.25);
    }

    .item-run-output .output-text {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-secondary);
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 150px;
      overflow-y: auto;
    }

    .metric-edit-block {
      margin-top: 6px;
      padding: 6px;
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 6px;
    }
    .metric-edit-title {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .metric-edit-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-xs);
    }
    .metric-edit-controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .metric-edit-controls.hidden { display: none; }
    .metric-edit-block.hidden { display: none; }
    .metric-edit-input {
      width: 90px;
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-default);
      border-radius: 6px;
      padding: 4px 6px;
      font-family: var(--font-mono);
      font-size: var(--font-xs);
    }
    .metric-edit-save {
      background: transparent;
      border: 1px solid var(--border-default);
      color: var(--text-primary);
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: var(--font-xs);
    }
    .metric-edit-save:disabled { opacity: 0.6; cursor: default; }
    .metric-edit-status {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }
    .metric-edit-badge {
      display: inline-flex;
      align-items: center;
      padding: 1px 5px;
      background: rgba(34,197,94,0.15);
      color: var(--success);
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
    }
    .metric-edit-badge::before {
      content: "●";
      font-size: 7px;
      margin-right: 4px;
    }
    .metric-edit-open {
      background: #1f2430;
      border: none;
      color: #a7b0c0;
      border-radius: 6px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 6px;
      line-height: 1;
      opacity: 0.95;
    }
    .metric-edit-open:hover {
      opacity: 1;
      background: #222a36;
      color: #c3c9d6;
    }
    .metric-edit-meta {
      margin-top: 4px;
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: var(--space-sm);
      margin-top: var(--space-lg);
    }

    .pagination button {
      padding: var(--space-xs) var(--space-md);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .pagination button:hover:not(:disabled) {
      background: var(--bg-hover);
    }

    .pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination .page-info {
      display: flex;
      align-items: center;
      font-size: var(--font-sm);
      color: var(--text-muted);
    }

    /* Empty/loading states */
    .compare-loading,
    .compare-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 300px;
      color: var(--text-muted);
    }

    .compare-loading .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border-default);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: var(--space-md);
    }

    /* Formatted object/dict display styles */
    .formatted-object,
    .formatted-array {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      line-height: 1.6;
    }

    .formatted-row {
      padding: 6px 0;
      padding-left: var(--space-md);
      border-left: 2px solid var(--border-subtle);
      margin-left: 2px;
      margin-bottom: 4px;
    }

    .formatted-row:hover {
      background: var(--bg-hover);
      border-left-color: var(--accent-primary);
    }

    .formatted-key {
      color: #f472b6;
      font-weight: 600;
      display: block;
      margin-bottom: 4px;
      text-transform: uppercase;
      font-size: var(--font-xs);
      letter-spacing: 0.5px;
    }

    .formatted-string {
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      display: block;
      line-height: 1.5;
    }

    .formatted-number {
      color: #fbbf24;
      font-weight: 600;
    }

    .formatted-boolean {
      color: #a855f7;
      font-weight: 600;
    }

    .formatted-null {
      color: var(--text-muted);
      font-style: italic;
    }

    .formatted-array-item {
      padding: 6px 0;
      padding-left: var(--space-md);
      border-left: 2px solid var(--border-subtle);
      margin-left: 2px;
      margin-bottom: 4px;
    }

    .formatted-array-item:hover {
      background: var(--bg-hover);
      border-left-color: var(--accent-primary);
    }

    .formatted-index {
      color: #60a5fa;
      font-size: var(--font-xs);
      margin-right: 4px;
      font-weight: 600;
    }

    /* Shared toggle button for metric details */
    .item-metric-details-toggle {
      margin-top: var(--space-md);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
    }

    .metric-details-toggle {
      font-size: var(--font-sm);
      color: var(--accent-primary);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 4px;
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
    }

    .metric-details-toggle:hover {
      background: var(--bg-hover);
      border-color: var(--accent-primary);
    }

    /* Per-run metric details (inside each run output) */
    .run-metric-details {
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
      display: none;
    }

    .run-metric-details.expanded {
      display: block;
    }

    .metric-detail-row {
      padding: 8px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metric-detail-row:last-child {
      border-bottom: none;
    }

    .metric-detail-name {
      font-size: var(--font-sm);
      color: #f472b6;
      font-weight: 600;
      margin-bottom: 6px;
      display: block;
    }

    .metric-detail-value {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.6;
    }

    /* Metric tabs */
    .metric-tabs {
      display: flex;
      gap: 2px;
      background: var(--bg-elevated);
      padding: 3px;
      border-radius: 6px;
      width: fit-content;
    }

    .metric-tab {
      padding: 6px 16px;
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .metric-tab:hover {
      color: var(--text-secondary);
      background: var(--bg-hover);
    }

    .metric-tab.active {
      color: var(--text-primary);
      background: var(--bg-surface);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Metric tabs row - contains tabs and threshold control */
    .metric-tabs-row {
      display: flex;
      align-items: center;
      gap: var(--space-lg);
      margin-bottom: var(--space-md);
      flex-wrap: wrap;
    }

    /* Threshold control */
    .threshold-control {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .threshold-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .threshold-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 120px;
      height: 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .threshold-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 212, 170, 0.4);
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .threshold-slider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 0 3px 10px rgba(0, 212, 170, 0.5);
    }

    .threshold-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--accent-primary);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 212, 170, 0.4);
    }

    .threshold-slider::-moz-range-track {
      background: var(--bg-elevated);
      height: 6px;
      border-radius: 3px;
    }

    .threshold-value {
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      font-weight: 600;
      color: var(--accent-primary);
      min-width: 40px;
    }

    /* (legacy .filter-label kept for any other usage) */
    .filter-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Winner indicator in item rows */
    .metric-winner {
      background: var(--success-dim);
      border-radius: 3px;
      padding: 0 4px;
      margin-left: 4px;
      font-size: var(--font-xs);
      color: var(--success);
    }

    .metric-score-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      padding: 2px 0;
    }
    .metric-score-meta {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .winner-badge {
      display: inline-flex;
      align-items: center;
      padding: 1px 5px;
      background: rgba(234, 179, 8, 0.2);
      color: #f59e0b;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
    }

    .metric-score-row.highlighted {
      background: var(--bg-hover);
      margin: 0 -4px;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .metric-score-name {
      font-size: var(--font-xs);
      color: var(--text-muted);
      min-width: 80px;
    }

    .metric-score-value {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      font-weight: 600;
    }

    .metric-scores-inline {
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
    }

    /* (old search/partial/metadata/filter-row-2 styles removed — now in filter-panel) */

    /* Clickable chart segments */
    .win-loss-bar .segment.clickable,
    .dist-segment.clickable {
      cursor: pointer;
      transition: opacity 0.15s, transform 0.15s;
    }
    .win-loss-bar .segment.clickable:hover,
    .dist-segment.clickable:hover {
      opacity: 0.85;
      transform: scaleY(1.08);
    }

    /* Copy button — icon only */
    .copy-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 2px;
      line-height: 1;
      opacity: 0.4;
      transition: all 0.15s;
      flex-shrink: 0;
      display: inline-flex;
      align-items: center;
    }
    .copy-btn svg { width: 14px; height: 14px; }
    .copy-btn:hover {
      opacity: 1;
    }
    .copy-btn:hover svg { stroke: var(--accent-primary); }
    .copy-btn.copied svg { stroke: var(--success); }
    .copy-btn.copied {
      opacity: 1;
    }
    /* Per-field copy on formatted rows */
    .formatted-row {
      position: relative;
    }
    .formatted-row > .copy-btn {
      position: absolute;
      top: 6px;
      right: 4px;
      opacity: 0;
    }
    .formatted-row:hover > .copy-btn {
      opacity: 0.4;
    }
    .formatted-row:hover > .copy-btn:hover {
      opacity: 1;
    }
    .formatted-row > .copy-btn.copied {
      opacity: 1;
    }

    /* Item metadata display */
    .item-metadata-row {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: 6px var(--space-sm);
      background: var(--bg-elevated);
      border-radius: 4px;
    }

    /* Complexity & Domain — first-class badges */
    .item-meta-badges {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }

    .meta-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 10px;
      border-radius: 100px;
      font-size: var(--font-xs);
      font-family: var(--font-mono);
      font-weight: 600;
      white-space: nowrap;
    }

    .meta-badge .badge-icon {
      font-size: 10px;
      line-height: 1;
    }

    .meta-badge.badge-complexity {
      background: rgba(249, 115, 22, 0.1);
      border: 1px solid rgba(249, 115, 22, 0.25);
      color: #fb923c;
    }

    /* Complexity value-specific colors */
    .meta-badge.badge-complexity.complexity-easy {
      background: rgba(34, 197, 94, 0.12);
      border-color: rgba(34, 197, 94, 0.3);
      color: #4ade80;
    }
    .meta-badge.badge-complexity.complexity-medium {
      background: rgba(234, 179, 8, 0.12);
      border-color: rgba(234, 179, 8, 0.3);
      color: #facc15;
    }
    .meta-badge.badge-complexity.complexity-hard {
      background: rgba(239, 68, 68, 0.12);
      border-color: rgba(239, 68, 68, 0.3);
      color: #f87171;
    }
    .meta-badge.badge-complexity.complexity-very-hard,
    .meta-badge.badge-complexity.complexity-expert {
      background: rgba(168, 85, 247, 0.12);
      border-color: rgba(168, 85, 247, 0.3);
      color: #c084fc;
    }

    .meta-badge.badge-domain {
      background: rgba(96, 165, 250, 0.1);
      border: 1px solid rgba(96, 165, 250, 0.25);
      color: #60a5fa;
    }

    /* Separator between badges and generic tags */
    .item-meta-sep {
      width: 1px;
      height: 16px;
      background: var(--border-default);
      flex-shrink: 0;
    }

    /* Generic metadata tags */
    .item-metadata-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .item-metadata-tag {
      display: inline-flex;
      gap: 4px;
      padding: 2px 8px;
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 4px;
      font-size: var(--font-xs);
      font-family: var(--font-mono);
    }
    .item-metadata-tag .meta-key {
      color: var(--text-muted);
    }
    .item-metadata-tag .meta-val {
      color: var(--text-secondary);
      font-weight: 600;
    }

    /* Metadata field selector */
    .metadata-fields-selector {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .metadata-fields-btn {
      background: transparent;
      border: 1px solid var(--border-default);
      color: var(--text-muted);
      border-radius: 3px;
      padding: var(--space-xs) var(--space-sm);
      padding-right: 24px;
      font-size: var(--font-sm);
      cursor: pointer;
      transition: all 0.15s;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239898a8' d='M3 4.5L6 8l3-3.5H3z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      white-space: nowrap;
    }
    .metadata-fields-btn:hover {
      background-color: var(--bg-hover);
      border-color: var(--border-strong);
      color: var(--text-primary);
    }
    .metadata-fields-dropdown {
      display: none;
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      background: var(--bg-elevated);
      border: 1px solid var(--border-default);
      border-radius: 6px;
      padding: var(--space-sm);
      z-index: 100;
      min-width: 180px;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .metadata-fields-dropdown.open { display: block; }
    .metadata-fields-dropdown label {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      font-size: var(--font-xs);
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 3px;
      transition: background 0.1s;
    }
    .metadata-fields-dropdown label:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    /* (export-btn styles now in .fp-btn.fp-export) */
  </style>
</head>
<body>
  <!-- Minimal header -->
  <header class="stats-bar">
    <div class="stats-bar-left">
      <a href="/" class="logo" style="text-decoration:none;">
        <img src="./static/qym_text.png" alt="قيِّم" class="logo-text-img" style="cursor:pointer;" />
      </a>
      <div class="stat-cells">
        <div class="stat-cell">
          <span class="stat-label">COMPARING</span>
          <span class="stat-value" id="run-count">—</span>
        </div>
        <div class="stat-cell">
          <span class="stat-label">TOTAL ITEMS</span>
          <span class="stat-value" id="total-items">—</span>
        </div>
        <div class="stat-cell">
          <span class="stat-label">METRICS</span>
          <span class="stat-value" id="metric-count">—</span>
        </div>
      </div>
    </div>
  </header>

  <main class="compare-container">
    <div class="compare-loading" id="loading">
      <div class="spinner"></div>
      <span>Loading comparison data...</span>
    </div>

    <div class="compare-empty" id="empty" style="display: none;">
      <div style="font-size: 48px; margin-bottom: var(--space-md);">∅</div>
      <h2>No runs to compare</h2>
      <p>Select at least 2 runs from the dashboard to compare.</p>
      <a href="" class="back-link" id="back-link-empty">← Back to Dashboard</a>
    </div>

    <div id="compare-content" style="display: none;">
      <div class="compare-header-bar">
        <div>
          <div class="compare-title">Run Comparison</div>
          <div class="compare-subtitle" id="compare-subtitle">Comparing evaluation runs</div>
        </div>
        <a href="" class="back-link" id="back-link-header">← Back to Dashboard</a>
      </div>

      <!-- Run summaries -->
      <div class="compare-summary" id="run-summaries"></div>

      <!-- Metrics comparison -->
      <div class="metrics-comparison">
        <h3>Metric Averages</h3>
        <table class="metrics-table" id="metrics-table">
          <thead id="metrics-thead"></thead>
          <tbody id="metrics-tbody"></tbody>
        </table>
      </div>

      <!-- Comparison Statistics -->
      <h3 class="section-title">Comparison Overview</h3>
      <div class="comparison-stats" id="comparison-stats">
        <div class="metric-tabs-row">
          <div class="metric-tabs" id="overview-metric-tabs"></div>
          <div class="threshold-control" id="threshold-control" style="display: none;">
            <span class="threshold-label">Pass if ≥</span>
            <input type="range" id="threshold-slider" class="threshold-slider" min="0" max="100" step="5" value="80">
            <span class="threshold-value" id="threshold-value">80%</span>
          </div>
        </div>
        <div class="stats-grid" id="stats-grid"></div>
      </div>

      <!-- Side-by-side items -->
      <div class="items-comparison">
        <h3 class="section-title">Item-by-Item Comparison</h3>

        <div class="filter-panel">
          <div class="fp-filter-row">
            <div class="fp-group">
              <span class="fp-label">Metric</span>
              <select id="items-metric-select" class="filter-select"></select>
            </div>
            <div class="fp-group">
              <span class="fp-label">Show</span>
              <select id="item-filter" class="filter-select">
                <option value="all">All Items</option>
                <option value="different">Different Outputs</option>
                <option value="errors">With Errors</option>
                <option value="all_correct">All Runs Correct</option>
                <option value="all_wrong">No Run Correct</option>
                <option value="partially_correct">Partially Correct</option>
                <option value="rarely_solved">Rarely Solved (&le;25%)</option>
                <option value="unique_solve">Uniquely Solved (1 run)</option>
              </select>
            </div>
            <div class="fp-group">
              <span class="fp-label">Winner</span>
              <select id="run-winner-filter" class="filter-select">
                <option value="any">Any Winner</option>
              </select>
            </div>
            <div class="fp-group fp-pass-rate-group">
              <span class="fp-label">Pass Rate</span>
              <div class="fp-pass-rate-row">
                <select id="pass-rate-op" class="filter-select">
                  <option value="">Any</option>
                  <option value="gte">&ge;</option>
                  <option value="lte">&le;</option>
                  <option value="eq">=</option>
                </select>
                <input type="number" id="pass-rate-value" class="fp-pass-rate-input" min="0" value="0" style="display:none;" />
                <span class="fp-pass-rate-suffix" id="pass-rate-suffix" style="display:none;">of <span id="pass-rate-k">0</span> runs</span>
              </div>
            </div>
            <div class="fp-group fp-cat-group" id="fp-cat-complexity" style="display:none;">
              <span class="fp-label">Complexity</span>
              <div class="multi-select-wrapper">
                <button class="multi-select-btn" id="complexity-ms-btn">All Complexity</button>
                <div class="multi-select-dropdown" id="complexity-ms-dropdown"></div>
              </div>
            </div>
            <div class="fp-group fp-cat-group" id="fp-cat-domain" style="display:none;">
              <span class="fp-label">Domain</span>
              <div class="multi-select-wrapper">
                <button class="multi-select-btn" id="domain-ms-btn">All Domains</button>
                <div class="multi-select-dropdown" id="domain-ms-dropdown"></div>
              </div>
            </div>
            <div class="fp-gear-wrapper" id="fp-meta-fields" style="display:none;">
              <div class="metadata-fields-selector" style="position:relative;">
                <button class="fp-gear-btn metadata-fields-btn" id="metadata-fields-btn" title="Choose which metadata fields to display">&#9881;</button>
                <div class="metadata-fields-dropdown" id="metadata-fields-dropdown"></div>
              </div>
            </div>
            <div class="fp-actions-spacer"></div>
            <div class="fp-actions">
              <button class="fp-clear-btn" id="clear-all-btn" title="Clear all active filters">
                <span class="fp-clear-x">&times;</span> Clear <span class="fp-clear-count" id="active-filter-count">0</span>
              </button>
              <button class="fp-btn fp-export" id="export-filtered-btn" title="Export filtered items as CSV">Export CSV</button>
            </div>
          </div>
          <div class="fp-search-row">
            <div class="fp-search">
              <span class="fp-search-icon">&#x2315;</span>
              <input type="text" id="items-search" placeholder="Search questions / inputs..." />
            </div>
          </div>
          <div class="fp-status">
            <span class="filter-count" id="filter-count"></span>
          </div>
        </div>

        <div class="items-grid" id="items-grid"></div>
        <div class="pagination" id="pagination"></div>
      </div>
    </div>
  </main>

  <script>
    (() => {
      'use strict';

      // Base URL handling for proxy/subpath compatibility
      const BASE_URL = (() => {
        const loc = window.location;
        let base = loc.pathname;
        if (!base.endsWith('/')) {
          base = base.substring(0, base.lastIndexOf('/') + 1) || '/';
        }
        return loc.origin + base;
      })();

      function apiUrl(path) {
        const cleanPath = path.replace(/^\.?\//, '');
        return BASE_URL + cleanPath;
      }

      // Fix back links for subpath/proxy deployments.
      try {
        const backUrl = apiUrl('');
        const backHeader = document.getElementById('back-link-header');
        const backEmpty = document.getElementById('back-link-empty');
        if (backHeader) backHeader.href = backUrl;
        if (backEmpty) backEmpty.href = backUrl;
      } catch {}

      const COLORS = [
        '#00d4aa', '#00a8ff', '#a855f7', '#f472b6',
        '#fbbf24', '#60a5fa', '#34d399', '#fb923c'
      ];

      const state = {
        runs: [],
        allMetrics: [],
        selectedOverviewMetric: null,  // For Comparison Overview tabs
        selectedItemsMetric: null,     // For Item-by-Item filters
        itemFilter: 'all',
        winnerFilter: 'any',
        page: 1,
        pageSize: 20,
        comparisonStats: {},  // Now keyed by metric name
        metricThresholds: {},  // Per-metric threshold for "correct" (0-1 scale)
        metricIsBoolean: {},   // Per-metric flag: true if all scores are 0 or 1
        langfuseHost: '',      // Langfuse host URL
        langfuseProjectId: '', // Langfuse project ID
        // Group A additions
        searchQuery: '',              // #19: search items by input text
        complexityFilter: null,       // #2: null = all (default), [] = none, [...] = specific values
        domainFilter: null,           // #2: null = all (default), [] = none, [...] = specific values
        complexityValues: [],         // unique complexity values found in data
        domainValues: [],             // unique domain values found in data
        passRateOp: '',               // #20: '' = any, 'gte' = at least, 'lte' = at most, 'eq' = exactly
        passRateValue: 0,             // #20: the number for the pass rate filter
        allMetadataKeys: [],          // collected metadata keys across all items
        visibleMetadataFields: {},    // #6: which metadata fields to show (key -> bool)
      };

      const el = (id) => document.getElementById(id);

      function getSuccessClass(rate) {
        if (rate >= 0.9) return 'score-5';
        if (rate >= 0.75) return 'score-4';
        if (rate >= 0.6) return 'score-3';
        if (rate >= 0.4) return 'score-2';
        return 'score-1';
      }

      // Use shared utilities from metrics.js
      const formatPercent = window.QymMetrics.formatPercent;
      const formatLatency = window.QymMetrics.formatLatency;

      function formatTaskStart(ms) {
        if (!ms || ms <= 0) return null;
        try {
          const d = new Date(ms);
          const pad = (n) => String(n).padStart(2, '0');
          const yyyy = d.getFullYear();
          const mm = pad(d.getMonth() + 1);
          const dd = pad(d.getDate());
          const hh = pad(d.getHours());
          const min = pad(d.getMinutes());
          const sec = pad(d.getSeconds());
          const ts = `${yyyy}-${mm}-${dd} ${hh}:${min}:${sec}`;
          return { ts };
        } catch {
          return null;
        }
      }

      function buildLangfuseTraceUrl(traceId) {
        if (!traceId || !state.langfuseHost || !state.langfuseProjectId) return null;
        const host = state.langfuseHost.replace(/\/$/, '');
        return `${host}/project/${state.langfuseProjectId}/traces/${traceId}`;
      }

      function buildLangfuseTraceUrlFromRun(traceId, runInfo) {
        const host = (runInfo.langfuse_host || '').replace(/\/$/, '');
        const projectId = runInfo.langfuse_project_id || '';
        if (!traceId || !host || !projectId) return null;
        return `${host}/project/${projectId}/traces/${traceId}`;
      }

      function buildDistributionBar(stats) {
        return stats.correctDistribution.map((count, idx) => {
          if (count === 0) return '';
          const pct = (count / stats.totalCompared * 100).toFixed(0);
          const isZero = idx === 0;
          const isAll = idx === state.runs.length;
          const colorClass = isZero ? 'dist-zero' : isAll ? 'dist-all' : 'dist-partial';
          return `<div class="dist-segment ${colorClass} clickable" style="flex: ${count}" data-dist-count="${idx}" title="${idx}/${state.runs.length} correct: ${count} items (${pct}%) — Click to filter">
            <span class="dist-label">${idx}</span>
            <span class="dist-count">${count}</span>
          </div>`;
        }).join('');
      }

      async function loadComparisonData() {
        // Get selected files from sessionStorage
        const filesJson = sessionStorage.getItem('compareRuns');
        if (!filesJson) {
          showEmpty();
          return;
        }

        let files;
        try {
          files = JSON.parse(filesJson);
        } catch {
          showEmpty();
          return;
        }

        if (!Array.isArray(files) || files.length < 2) {
          showEmpty();
          return;
        }

        // Fetch comparison data from API
        const params = files.map(f => 'files=' + encodeURIComponent(f)).join('&');
        try {
          const compareResponse = await fetch(apiUrl('api/compare?' + params));
          const data = await compareResponse.json();

          if (!data.runs || data.runs.length < 2) {
            showEmpty();
            return;
          }

          state.runs = data.runs;
          state.langfuseHost = data.langfuse_host || '';
          state.langfuseProjectId = data.langfuse_project_id || '';
          // Fallback: use per-run Langfuse config if top-level is incomplete
          if ((!state.langfuseHost || !state.langfuseProjectId) && data.runs?.length) {
            const firstRun = data.runs[0]?.run || {};
            state.langfuseHost = state.langfuseHost || firstRun.langfuse_host || '';
            state.langfuseProjectId = state.langfuseProjectId || firstRun.langfuse_project_id || '';
          }
          processRuns();
          render();
        } catch (err) {
          console.error('Failed to load comparison:', err);
          showEmpty();
        }
      }

      function processRuns() {
        // Collect all unique metrics
        const metricsSet = new Set();
        for (const run of state.runs) {
          const snap = run.snapshot || {};
          const names = snap.metric_names || run.run?.metric_names || [];
          names.forEach(m => metricsSet.add(m));
        }
        state.allMetrics = Array.from(metricsSet).sort();

        // Set default selected metrics
        if (state.allMetrics.length > 0) {
          state.selectedOverviewMetric = state.allMetrics[0];
          state.selectedItemsMetric = state.allMetrics[0];
        }

        // Update header stats
        el('run-count').textContent = state.runs.length;
        el('metric-count').textContent = state.allMetrics.length;

        // Set up pass rate filter controls based on K
        const K = state.runs.length;
        const prValueInput = el('pass-rate-value');
        if (prValueInput) {
          prValueInput.max = K;
          prValueInput.value = Math.ceil(K / 2);
        }
        const prKSpan = el('pass-rate-k');
        if (prKSpan) prKSpan.textContent = K;

        // Calculate total items (use max across runs)
        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));
        el('total-items').textContent = maxItems;

        // Detect metric types (boolean vs continuous)
        detectMetricTypes();

        // Calculate comparison statistics for each metric
        state.comparisonStats = {};
        for (const metric of state.allMetrics) {
          state.comparisonStats[metric] = calculateComparisonStatsForMetric(metric);
        }

        // Collect all unique metadata keys and values for complexity/domain
        const metaKeySet = new Set();
        const complexitySet = new Set();
        const domainSet = new Set();
        for (const run of state.runs) {
          const rows = run.snapshot?.rows || [];
          for (const row of rows) {
            const md = row.item_metadata || {};
            if (typeof md === 'object') {
              for (const k of Object.keys(md)) {
                if (k !== 'task_started_at_ms') metaKeySet.add(k);
              }
              if (md.complexity != null && md.complexity !== '') complexitySet.add(String(md.complexity));
              if (md.domain != null && md.domain !== '') domainSet.add(String(md.domain));
            }
          }
        }
        state.allMetadataKeys = Array.from(metaKeySet).sort();
        const complexityOrder = ['easy', 'medium', 'hard'];
        state.complexityValues = Array.from(complexitySet).sort((a, b) => {
          const ai = complexityOrder.indexOf(a.toLowerCase());
          const bi = complexityOrder.indexOf(b.toLowerCase());
          return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);
        });
        state.domainValues = Array.from(domainSet).sort();

        // Initialize visible metadata fields (all on by default)
        for (const k of state.allMetadataKeys) {
          if (state.visibleMetadataFields[k] === undefined) {
            state.visibleMetadataFields[k] = true;
          }
        }

        // Build complexity/domain multi-select dropdowns
        buildCategoryDropdowns();

        // Populate metadata fields dropdown
        populateMetadataFieldsDropdown();

        // Populate metric selectors
        populateMetricSelectors();

        // Populate winner filter dropdown
        populateWinnerFilter();
      }

      function populateMetricSelectors() {
        const singleMetric = state.allMetrics.length <= 1;

        // Overview metric tabs — hide when single metric
        const tabsContainer = el('overview-metric-tabs');
        if (tabsContainer) {
          if (singleMetric) {
            tabsContainer.style.display = 'none';
          } else {
            tabsContainer.style.display = '';
            tabsContainer.innerHTML = state.allMetrics.map(metric =>
              `<button class="metric-tab ${metric === state.selectedOverviewMetric ? 'active' : ''}" data-metric="${metric}">${metric}</button>`
            ).join('');

            tabsContainer.querySelectorAll('.metric-tab').forEach(tab => {
              tab.addEventListener('click', () => {
                state.selectedOverviewMetric = tab.dataset.metric;
                tabsContainer.querySelectorAll('.metric-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                updateThresholdControl();
                renderComparisonStats();
                renderMetadataBreakdown();
              });
            });
          }
        }

        // Threshold slider (only for continuous metrics)
        const thresholdSlider = el('threshold-slider');
        const thresholdValue = el('threshold-value');
        if (thresholdSlider) {
          thresholdSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if (thresholdValue) thresholdValue.textContent = `${value}%`;
          });
          thresholdSlider.addEventListener('change', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value) && value >= 0 && value <= 100) {
              state.metricThresholds[state.selectedOverviewMetric] = value / 100;
              // Recalculate stats for this metric
              state.comparisonStats[state.selectedOverviewMetric] = calculateComparisonStatsForMetric(state.selectedOverviewMetric);
              // Also recalculate for items metric if different
              if (state.selectedItemsMetric && state.selectedItemsMetric !== state.selectedOverviewMetric) {
                state.comparisonStats[state.selectedItemsMetric] = calculateComparisonStatsForMetric(state.selectedItemsMetric);
              }
              renderComparisonStats();
              renderMetadataBreakdown();
              renderItems();
            }
          });
        }

        // Initial threshold control visibility
        updateThresholdControl();

        // Items metric selector dropdown — hide when single metric
        const itemsMetricSelect = el('items-metric-select');
        if (itemsMetricSelect) {
          const metricGroup = itemsMetricSelect.closest('.fp-group');
          if (singleMetric) {
            if (metricGroup) metricGroup.style.display = 'none';
          } else {
            if (metricGroup) metricGroup.style.display = '';
            itemsMetricSelect.innerHTML = state.allMetrics.map(metric =>
              `<option value="${metric}" ${metric === state.selectedItemsMetric ? 'selected' : ''}>${metric}</option>`
            ).join('');

            itemsMetricSelect.addEventListener('change', (e) => {
              state.selectedItemsMetric = e.target.value;
              state.page = 1;
              populateWinnerFilter();
              renderItems();
            });
          }
        }

        // Metrics Averages table — hide when single metric
        const metricsSection = document.querySelector('.metrics-comparison');
        if (metricsSection) metricsSection.style.display = singleMetric ? 'none' : '';
      }

      // Show/hide threshold control based on metric type
      function updateThresholdControl() {
        const thresholdControl = el('threshold-control');
        const thresholdSlider = el('threshold-slider');
        const thresholdValue = el('threshold-value');
        if (!thresholdControl || !thresholdSlider) return;

        const metric = state.selectedOverviewMetric;
        if (!metric) {
          thresholdControl.style.display = 'none';
          return;
        }

        const isBoolean = state.metricIsBoolean[metric];
        if (isBoolean) {
          thresholdControl.style.display = 'none';
        } else {
          thresholdControl.style.display = 'flex';
          // Set slider value to current threshold (as percentage)
          const pct = Math.round((state.metricThresholds[metric] ?? 0.8) * 100);
          thresholdSlider.value = pct;
          if (thresholdValue) thresholdValue.textContent = `${pct}%`;
        }
      }

      // Detect if a metric is boolean (all scores are 0 or 1) and initialize threshold
      function detectMetricTypes() {
        for (const metricName of state.allMetrics) {
          let allBoolean = true;

          for (const run of state.runs) {
            const snap = run.snapshot || {};
            const rows = snap.rows || [];
            const metricNames = snap.metric_names || run.run?.metric_names || [];
            const metricIdx = metricNames.indexOf(metricName);

            if (metricIdx < 0) continue;

            for (const row of rows) {
              const v = (row.metric_values || [])[metricIdx];
              const n = window.QymMetrics.parseScoreValue(v);
              if (n !== null) {
                // Check if score is NOT 0 or 1 (with tolerance)
                if (Math.abs(n) > 0.0001 && Math.abs(n - 1) > 0.0001) {
                  allBoolean = false;
                  break;
                }
              }
            }
            if (!allBoolean) break;
          }

          state.metricIsBoolean[metricName] = allBoolean;
          // Default threshold: 80% for continuous metrics
          if (!state.metricThresholds[metricName]) {
            state.metricThresholds[metricName] = 0.8;
          }
        }
      }

      function calculateComparisonStatsForMetric(metricName) {
        const stats = {
          wins: new Array(state.runs.length).fill(0),
          ties: 0,
          totalCompared: 0,
          avgScores: [],
          avgLatencies: [],
          scoreDelta: 0,
          latencyDelta: 0,
          agreementRate: 0,
          allCorrect: 0,
          allWrong: 0,
          passAtK: 0, // Items where at least one run scored 100%
          passHatK: 0, // Items where ALL runs scored 100%
          totalConsistencySum: 0, // Sum of per-item consistency scores
          totalReliabilitySum: 0, // Sum of per-item reliability (pass_count / K) for items with at least one pass
          itemsWithMultipleRuns: 0, // Count of items with K > 1 for consistency
          itemsWithAtLeastOnePass: 0, // Count of items where at least one run passed (for reliability)
          maxAtK: 0, // Sum of max scores across all items (best possible if you pick best run per item)
          failedCount: 0, // Total number of failed attempts across all items and runs
          correctDistribution: [], // How many items had 0, 1, 2, ... N runs correct
          overallAvgScore: 0,
          overallAvgLatency: 0,
          errorCounts: [],
          errorTypes: [],
          biggestWins: [],
          itemWinners: [], // For each item, which run won
        };

        // Collect all unique item_ids across all runs for proper alignment
        const allItemIds = new Set();
        for (const run of state.runs) {
          const rows = run.snapshot?.rows || [];
          for (const row of rows) {
            // Use item_id if available, otherwise fallback to index
            const itemId = row.item_id || String(row.index);
            allItemIds.add(itemId);
          }
        }
        const itemIdList = Array.from(allItemIds);

        // Create a map from item_id to array index for itemWinners tracking
        state.itemIdToIndex = {};
        itemIdList.forEach((id, idx) => { state.itemIdToIndex[id] = idx; });

        // Initialize correct distribution array (index = number of runs correct, value = count)
        stats.correctDistribution = new Array(state.runs.length + 1).fill(0);

        // Helper to get metric index for a run
        function getMetricIndex(run) {
          const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
          return metricNames.indexOf(metricName);
        }

        // Calculate per-run stats
        for (let runIdx = 0; runIdx < state.runs.length; runIdx++) {
          const run = state.runs[runIdx];
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricIdx = getMetricIndex(run);

          let scoreSum = 0, scoreCount = 0, latSum = 0, latCount = 0;
          let timeoutErrors = 0, runtimeErrors = 0, otherErrors = 0;

          for (const row of rows) {
            // Score for the selected metric (use centralized error handling)
            if (metricIdx >= 0) {
              const { score } = window.QymMetrics.getRowScore(row, metricIdx);
              if (score !== null) { scoreSum += score; scoreCount++; }
            }
            // Latency
            if (row.latency_ms && row.status === 'completed') {
              latSum += row.latency_ms;
              latCount++;
            }
            // Errors (use centralized check)
            if (window.QymMetrics.isErrorRow(row)) {
              const output = (row.output_full || row.output || '').toLowerCase();
              if (output.includes('timeout')) timeoutErrors++;
              else if (output.includes('error')) runtimeErrors++;
              else otherErrors++;
            }
          }

          stats.avgScores.push(scoreCount > 0 ? scoreSum / scoreCount : 0);
          stats.avgLatencies.push(latCount > 0 ? latSum / latCount : 0);
          stats.errorCounts.push(timeoutErrors + runtimeErrors + otherErrors);
          stats.errorTypes.push({ timeout: timeoutErrors, runtime: runtimeErrors, other: otherErrors });
        }

        // Compare items head-to-head using item_id for alignment
        let agreements = 0;
        for (const itemId of itemIdList) {
          const scoresWithStatus = state.runs.map((run) => {
            const snap = run.snapshot || {};
            const rows = snap.rows || [];
            // Match by item_id, fallback to index for legacy data
            const row = rows.find(r => (r.item_id || String(r.index)) === itemId);
            if (!row) return { score: null, failed: false };
            const metricIdx = getMetricIndex(run);
            if (metricIdx < 0) return { score: null, failed: false };
            // Use centralized error handling from metrics.js
            const { score, isError } = window.QymMetrics.getRowScore(row, metricIdx);
            return { score, failed: isError };
          });

          // Count failed attempts
          stats.failedCount += scoresWithStatus.filter(s => s.failed).length;

          const scores = scoresWithStatus.map(s => s.score);
          const validScores = scores.filter(s => s !== null);

          // Max@K: track the best score for this item across all runs (not affected by threshold)
          if (validScores.length > 0) {
            stats.maxAtK += Math.max(...validScores);
          }

          // Determine threshold for "correct": 1.0 for boolean, user-defined for continuous
          const isBoolean = state.metricIsBoolean[metricName];
          const threshold = isBoolean ? 0.9999 : state.metricThresholds[metricName];

          // Count distribution for ALL items (even those with missing data)
          const numCorrect = scores.filter(s => s !== null && s >= threshold).length;
          stats.correctDistribution[numCorrect]++;

          // For head-to-head comparison, need at least 2 valid scores
          if (validScores.length < 2) {
            stats.itemWinners.push(null);
            // Still count pass@k for items with any data
            if (numCorrect > 0) stats.passAtK++;
            if (scores.every(s => s === null || s < 0.0001)) stats.allWrong++;
            if (numCorrect === scores.filter(s => s !== null).length && numCorrect > 0) stats.allCorrect++;
            stats.totalCompared++;
            continue;
          }

          stats.totalCompared++;

          const maxScore = Math.max(...validScores);
          const minScore = Math.min(...validScores);
          const winners = scores.map((s, idx) => s === maxScore ? idx : -1).filter(x => x >= 0);

          // Check if ALL scores are the same (true tie)
          if (maxScore === minScore) {
            stats.ties++;
            stats.itemWinners.push('tie');
          } else if (winners.length === 1) {
            // Clear winner - only one run has the HIGHEST score (beat all others)
            stats.wins[winners[0]]++;
            stats.itemWinners.push(winners[0]);
            // Track biggest wins
            const diff = maxScore - minScore;
            stats.biggestWins.push({ itemId: itemId, winner: winners[0], diff, scores });
          } else {
            // Multiple runs tied for the highest score, but didn't beat everyone
            // This counts as a tie (no clear winner)
            stats.ties++;
            stats.itemWinners.push('tie');
          }

          // All correct / all wrong / pass@k (at least one run meets threshold)
          // Note: numCorrect was already calculated above using threshold
          const allCorrectItem = numCorrect === validScores.length && validScores.length > 0;
          const allZeroItem = validScores.every(s => s < 0.0001); // All scores are 0%

          if (allCorrectItem) stats.allCorrect++;
          if (allZeroItem) stats.allWrong++;
          if (numCorrect > 0) stats.passAtK++;

          // Pass^K: ALL runs meet threshold
          if (allCorrectItem) stats.passHatK++;

          // Consistency: binary agreement (do runs agree on pass/fail?)
          // Formula: 2 * max(passCount, failCount) / K - 1
          // Range: 0% (50/50 split) to 100% (all agree)
          if (validScores.length > 1) {
            const numFail = validScores.length - numCorrect;
            const maxAgreement = Math.max(numCorrect, numFail);
            const itemConsistency = (2 * maxAgreement / validScores.length) - 1;
            stats.totalConsistencySum += itemConsistency;
            stats.itemsWithMultipleRuns++;

            // Reliability: when it CAN answer correctly, how often does it?
            // Only include items with at least one passing run
            if (numCorrect > 0) {
              const itemReliability = numCorrect / validScores.length;
              stats.totalReliabilitySum += itemReliability;
              stats.itemsWithAtLeastOnePass++;
            }
          }

          // Agreement (runs scored similarly - within 10% of each other)
          const scoreRange = maxScore - minScore;
          if (scoreRange < 0.1) agreements++;
        }

        stats.agreementRate = stats.totalCompared > 0 ? agreements / stats.totalCompared : 0;

        // Calculate overall averages across all runs
        const validScoresAll = stats.avgScores.filter(s => s > 0);
        const validLatenciesAll = stats.avgLatencies.filter(l => l > 0);
        stats.overallAvgScore = validScoresAll.length > 0
          ? validScoresAll.reduce((a, b) => a + b, 0) / validScoresAll.length
          : 0;
        stats.overallAvgLatency = validLatenciesAll.length > 0
          ? validLatenciesAll.reduce((a, b) => a + b, 0) / validLatenciesAll.length
          : 0;

        // Score and latency deltas (comparing first two runs)
        if (state.runs.length >= 2) {
          stats.scoreDelta = stats.avgScores[0] - stats.avgScores[1];
          stats.latencyDelta = stats.avgLatencies[0] - stats.avgLatencies[1];
        }

        // Sort biggest wins
        stats.biggestWins.sort((a, b) => b.diff - a.diff);
        stats.biggestWins = stats.biggestWins.slice(0, 5);

        return stats;
      }

      function populateWinnerFilter() {
        const select = el('run-winner-filter');
        if (!select) return;

        // Save current value to restore after repopulating
        const currentValue = state.winnerFilter;

        let options = '<option value="any">Any Winner</option>';
        options += '<option value="tie">Ties Only</option>';

        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="win_${idx}">${name} Won</option>`;
        });

        // Add "Only X Solved" options for unique insights
        options += '<optgroup label="Uniquely Solved By">';
        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="only_${idx}">Only ${name}</option>`;
        });
        options += '</optgroup>';

        select.innerHTML = options;

        // Restore previous selection if it still exists
        if (select.querySelector(`option[value="${currentValue}"]`)) {
          select.value = currentValue;
        } else {
          state.winnerFilter = 'any';
        }
      }

      function removeRun(idx) {
        if (state.runs.length <= 2) return;

        // Remove from state
        state.runs.splice(idx, 1);

        // Update sessionStorage so it persists
        const filesJson = sessionStorage.getItem('compareRuns');
        if (filesJson) {
          try {
            const files = JSON.parse(filesJson);
            files.splice(idx, 1);
            sessionStorage.setItem('compareRuns', JSON.stringify(files));
          } catch {}
        }

        // Reset filters that might reference removed run
        state.winnerFilter = 'any';
        state.page = 1;

        // Reprocess and re-render
        processRuns();
        render();
      }

      function showEmpty() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'flex';
        el('compare-content').style.display = 'none';
      }

      function render() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'none';
        el('compare-content').style.display = 'block';

        renderSummaries();
        renderComparisonStats();
        renderMetadataBreakdown();
        renderMetricsTable();
        renderItems();
      }

      // #3: Render complexity/domain metadata breakdown with avg score, avg latency & consistency
      function renderMetadataBreakdown() {
        // Look for 'complexity' and 'domain' keys in item metadata
        const breakdownKeys = ['complexity', 'domain'].filter(k => state.allMetadataKeys.includes(k));
        if (breakdownKeys.length === 0) return;

        let existingSection = document.getElementById('metadata-breakdown');
        if (!existingSection) {
          existingSection = document.createElement('div');
          existingSection.id = 'metadata-breakdown';
          existingSection.style.marginBottom = 'var(--space-xl)';
          const statsEl = el('comparison-stats');
          if (statsEl && statsEl.parentNode) {
            statsEl.parentNode.insertBefore(existingSection, statsEl.nextSibling);
          }
        }

        const selectedMetric = state.selectedOverviewMetric || state.allMetrics[0];
        if (!selectedMetric) return;

        const isBoolean = state.metricIsBoolean[selectedMetric];
        const correctThreshold = isBoolean ? 0.9999 : (state.metricThresholds[selectedMetric] || 0.8);
        const K = state.runs.length;

        let html = '<h3 class="section-title">Performance by Category</h3><div class="comparison-stats">';

        for (const bdKey of breakdownKeys) {
          // Collect per-item-id data grouped by the breakdown key value
          // We need item-level aggregation (across runs) for consistency
          const itemsByGroup = {}; // groupVal -> { itemId -> { scores: [], latencies: [] } }

          for (let runIdx = 0; runIdx < state.runs.length; runIdx++) {
            const run = state.runs[runIdx];
            const rows = run.snapshot?.rows || [];
            const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
            const mIdx = metricNames.indexOf(selectedMetric);

            for (const row of rows) {
              const md = row.item_metadata || {};
              const groupVal = String(md[bdKey] ?? 'unknown');
              const itemId = row.item_id || String(row.index);

              if (!itemsByGroup[groupVal]) itemsByGroup[groupVal] = {};
              if (!itemsByGroup[groupVal][itemId]) itemsByGroup[groupVal][itemId] = { scores: [], latencies: [] };

              if (mIdx >= 0) {
                const { score } = window.QymMetrics.getRowScore(row, mIdx);
                if (score !== null) itemsByGroup[groupVal][itemId].scores.push(score);
              }
              if (row.latency_ms && row.status === 'completed') {
                itemsByGroup[groupVal][itemId].latencies.push(row.latency_ms);
              }
            }
          }

          // Compute stats per group
          const groupStats = [];
          for (const [groupVal, items] of Object.entries(itemsByGroup)) {
            const itemIds = Object.keys(items);
            let totalScoreSum = 0, totalScoreCount = 0;
            let totalLatSum = 0, totalLatCount = 0;
            let consistencySum = 0, consistencyCount = 0;

            for (const itemId of itemIds) {
              const { scores, latencies } = items[itemId];

              // Avg score — flat across all run observations
              for (const s of scores) { totalScoreSum += s; totalScoreCount++; }

              // Avg latency — flat across all run observations
              for (const l of latencies) { totalLatSum += l; totalLatCount++; }

              // Consistency: binary agreement (do runs agree on pass/fail?)
              // Same formula as main stats: 2 * max(passCount, failCount) / K - 1
              if (scores.length > 1) {
                const numCorrect = scores.filter(s => s >= correctThreshold).length;
                const numFail = scores.length - numCorrect;
                const maxAgreement = Math.max(numCorrect, numFail);
                const itemConsistency = (2 * maxAgreement / scores.length) - 1;
                consistencySum += itemConsistency;
                consistencyCount++;
              }
            }

            const avgScore = totalScoreCount > 0 ? totalScoreSum / totalScoreCount : 0;
            const avgLatency = totalLatCount > 0 ? totalLatSum / totalLatCount : null;
            const consistency = consistencyCount > 0 ? consistencySum / consistencyCount : null;

            groupStats.push({ groupVal, itemCount: itemIds.length, avgScore, avgLatency, consistency });
          }

          if (bdKey === 'complexity') {
            const cOrder = ['easy', 'medium', 'hard'];
            groupStats.sort((a, b) => {
              const ai = cOrder.indexOf(a.groupVal.toLowerCase().trim());
              const bi = cOrder.indexOf(b.groupVal.toLowerCase().trim());
              return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);
            });
          } else {
            groupStats.sort((a, b) => a.groupVal.localeCompare(b.groupVal));
          }
          if (groupStats.length === 0) continue;

          const icon = bdKey === 'complexity' ? '\u2666' : '\u25C6';
          const colorClass = bdKey === 'complexity' ? 'breakdown-complexity' : 'breakdown-domain';

          html += `<div class="breakdown-section ${colorClass}">`;
          html += `<div class="breakdown-header"><span class="breakdown-icon">${icon}</span> ${escapeHtml(bdKey.charAt(0).toUpperCase() + bdKey.slice(1))} <span class="breakdown-metric">${escapeHtml(selectedMetric)}</span></div>`;
          html += '<div class="breakdown-grid">';

          for (const g of groupStats) {
            const latStr = g.avgLatency !== null ? formatLatency(g.avgLatency) : '—';
            const consStr = g.consistency !== null ? formatPercent(g.consistency) : '—';
            const consClass = g.consistency !== null ? scoreColorClass(g.consistency) : '';

            // Add value-specific class for complexity breakdown cards
            let cardValClass = '';
            if (bdKey === 'complexity') {
              const cv = g.groupVal.toLowerCase().trim();
              if (['easy', 'simple', 'basic', 'low'].includes(cv)) cardValClass = ' complexity-easy';
              else if (['medium', 'moderate', 'intermediate', 'mid'].includes(cv)) cardValClass = ' complexity-medium';
              else if (['hard', 'difficult', 'advanced', 'high'].includes(cv)) cardValClass = ' complexity-hard';
              else if (['very hard', 'very_hard', 'expert', 'extreme'].includes(cv)) cardValClass = ' complexity-expert';
            }

            html += `<div class="breakdown-card${cardValClass}">
              <div class="breakdown-card-top">
                <div class="breakdown-card-label">${escapeHtml(g.groupVal)}</div>
                <div class="breakdown-card-count"><strong>${g.itemCount}</strong> item${g.itemCount !== 1 ? 's' : ''}</div>
              </div>
              <div class="breakdown-card-score ${scoreColorClass(g.avgScore)}">${formatPercent(g.avgScore)}</div>
              <div class="breakdown-card-details">
                <span class="breakdown-detail"><span class="breakdown-detail-label">Latency</span> ${latStr}</span>
                <span class="breakdown-detail"><span class="breakdown-detail-label">Consistency</span> <span class="${consClass}">${consStr}</span></span>
              </div>
            </div>`;
          }

          html += '</div></div>';
        }

        html += '</div>';
        existingSection.innerHTML = html;
      }

      // Helper to create info icon with tooltip
      function infoIcon(tooltip) {
        return `<span class="stat-info-icon">i<span class="stat-info-tooltip">${tooltip}</span></span>`;
      }

      // Helper to get color class based on percentage (0-1) - matches getSuccessClass thresholds
      function scoreColorClass(value) {
        if (value >= 0.9) return 'score-5';
        if (value >= 0.75) return 'score-4';
        if (value >= 0.6) return 'score-3';
        if (value >= 0.4) return 'score-2';
        return 'score-1';
      }

      function renderComparisonStats() {
        const container = el('stats-grid');
        if (!container || !state.comparisonStats || !state.selectedOverviewMetric) return;

        const stats = state.comparisonStats[state.selectedOverviewMetric];
        if (!stats) return;
        const runNames = state.runs.map((r, i) => r.run?.run_name || `Run ${i + 1}`);
        const K = state.runs.length;

        // Build win/loss bar with proper colors
        const total = stats.totalCompared || 1;
        const winBarSegments = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          const count = stats.wins[idx];
          if (count === 0) return '';
          return `<div class="segment clickable" style="flex: ${count}; background: ${color}" data-winner-filter="win_${idx}" title="Click to filter items won by this run">${count}</div>`;
        }).join('');
        const tieSegment = stats.ties > 0
          ? `<div class="segment tie clickable" style="flex: ${stats.ties}" data-winner-filter="tie" title="Click to filter ties">${stats.ties}</div>`
          : '';

        // Build legend
        const legendItems = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          return `<div class="legend-item">
            <div class="legend-dot" style="background: ${color}"></div>
            <span>${runNames[idx]}:</span>
            <span class="legend-count">${stats.wins[idx]}</span>
          </div>`;
        }).join('');
        const tieLegend = `<div class="legend-item">
          <div class="legend-dot" style="background: var(--text-muted)"></div>
          <span>Ties:</span>
          <span class="legend-count">${stats.ties}</span>
        </div>`;

        // Tooltips for each metric - adjust based on boolean vs continuous
        const isBoolean = state.metricIsBoolean[state.selectedOverviewMetric];
        const threshold = Math.round((state.metricThresholds[state.selectedOverviewMetric] ?? 0.8) * 100);
        const correctDef = isBoolean ? '100%' : `≥${threshold}%`;

        const tooltips = {
          passAtK: isBoolean
            ? `Percentage of items where <strong>at least one</strong> of the ${K} runs achieved a perfect score (100%). Measures coverage - can any run solve this item?`
            : `Percentage of items where <strong>at least one</strong> of the ${K} runs scored <strong>≥${threshold}%</strong>. Adjust the threshold above to change what counts as "correct".`,
          passHatK: isBoolean
            ? `Percentage of items where <strong>all ${K} runs</strong> achieved a perfect score (100%). Measures consistency - do all runs reliably solve this item?`
            : `Percentage of items where <strong>all ${K} runs</strong> scored <strong>≥${threshold}%</strong>. Adjust the threshold above to change what counts as "correct".`,
          maxAtK: `Average of the <strong>best score</strong> across all ${K} runs for each item. Shows the upper bound of what your runs can achieve.`,
          consistency: `Measures how often runs <strong>agree on pass/fail</strong> across ${K} runs. <strong>100%</strong> = all runs agree, <strong>0%</strong> = 50/50 split.`,
          reliability: `When an item <strong>CAN be solved</strong>, how often is it? Only includes items with <strong>≥1 passing run</strong>.`,
          failedCount: `Number of runs that <strong>threw an error</strong> (across all items). Errors are scored as 0%.`,
          avgScore: `The <strong>mean score</strong> across all items and all runs. A general measure of overall performance.`,
          avgLatency: `The <strong>mean response time</strong> across all items and all runs. Lower is better.`,
          winnerBreakdown: `Shows which run "won" (scored highest) for each item. Ties occur when multiple runs share the top score. Helps identify which run performs best most often.`,
          correctDist: isBoolean
            ? `Distribution showing how many runs got each item correct. "0 runs" = no run solved it, "${K} runs" = all runs solved it. Helps identify easy vs hard items.`
            : `Distribution showing how many runs scored ≥${threshold}% for each item. Adjust the threshold above to change what counts as "correct".`
        };

        container.innerHTML = `
          <div class="stats-row">
            <div class="stat-box">
              <div class="stat-title">Pass@${K} ${infoIcon(tooltips.passAtK)}</div>
              <div class="stat-main ${scoreColorClass(stats.passAtK / stats.totalCompared)}">${formatPercent(stats.passAtK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Pass^${K} ${infoIcon(tooltips.passHatK)}</div>
              <div class="stat-main ${scoreColorClass(stats.passHatK / stats.totalCompared)}">${formatPercent(stats.passHatK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Max@${K} ${infoIcon(tooltips.maxAtK)}</div>
              <div class="stat-main ${scoreColorClass(stats.maxAtK / stats.totalCompared)}">${formatPercent(stats.maxAtK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Consistency ${infoIcon(tooltips.consistency)}</div>
              <div class="stat-main ${scoreColorClass(stats.itemsWithMultipleRuns > 0 ? stats.totalConsistencySum / stats.itemsWithMultipleRuns : 0)}">${formatPercent(stats.itemsWithMultipleRuns > 0 ? stats.totalConsistencySum / stats.itemsWithMultipleRuns : 0)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Reliability ${infoIcon(tooltips.reliability)}</div>
              <div class="stat-main ${scoreColorClass(stats.itemsWithAtLeastOnePass > 0 ? stats.totalReliabilitySum / stats.itemsWithAtLeastOnePass : 0)}">${formatPercent(stats.itemsWithAtLeastOnePass > 0 ? stats.totalReliabilitySum / stats.itemsWithAtLeastOnePass : 0)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Score ${infoIcon(tooltips.avgScore)}</div>
              <div class="stat-main ${scoreColorClass(stats.overallAvgScore)}">${formatPercent(stats.overallAvgScore)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Latency ${infoIcon(tooltips.avgLatency)}</div>
              <div class="stat-main">${formatLatency(stats.overallAvgLatency)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Errors ${infoIcon(tooltips.failedCount)}</div>
              <div class="stat-main ${stats.failedCount > 0 ? 'score-1' : ''}">${stats.failedCount}</div>
            </div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Winner Breakdown ${infoIcon(tooltips.winnerBreakdown)}</div>
            <div class="win-loss-bar">
              ${winBarSegments}
              ${tieSegment}
            </div>
            <div class="win-loss-legend">
              ${legendItems}
              ${tieLegend}
            </div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Correct Distribution ${infoIcon(tooltips.correctDist)}</div>
            <div class="distribution-bar">
              ${buildDistributionBar(stats)}
            </div>
          </div>
        `;

        // #11: Wire click handlers on winner breakdown segments
        container.querySelectorAll('.segment.clickable[data-winner-filter]').forEach(seg => {
          seg.addEventListener('click', () => {
            const val = seg.dataset.winnerFilter;
            state.winnerFilter = val;
            const winnerSelect = el('run-winner-filter');
            if (winnerSelect && winnerSelect.querySelector(`option[value="${val}"]`)) {
              winnerSelect.value = val;
            }
            state.page = 1;
            renderItems(true);
          });
        });

        // #11: Wire click handlers on distribution bar segments
        container.querySelectorAll('.dist-segment.clickable[data-dist-count]').forEach(seg => {
          seg.addEventListener('click', () => {
            const count = seg.dataset.distCount;
            state.passRateOp = 'eq';
            state.passRateValue = Number(count);
            el('pass-rate-op').value = 'eq';
            el('pass-rate-value').value = count;
            el('pass-rate-value').style.display = '';
            el('pass-rate-suffix').style.display = '';
            state.page = 1;
            renderItems(true);
          });
        });
      }

      function renderSummaries() {
        const container = el('run-summaries');
        container.innerHTML = state.runs.map((run, idx) => {
          const info = run.run || {};
          const snap = run.snapshot || {};
          const stats = snap.stats || {};
          const color = COLORS[idx % COLORS.length];
          const successRate = (stats.completed || 0) / (stats.total || 1);
          const successClass = getSuccessClass(successRate);
          const canRemove = state.runs.length > 2;
          return `
            <div class="run-summary-card">
              <div class="run-header">
                <div class="run-color-dot" style="background: ${color}"></div>
                <div class="run-name">${info.run_name || 'Run ' + (idx + 1)}</div>
                ${canRemove ? `<button class="remove-run" data-idx="${idx}" title="Remove from comparison">✕</button>` : ''}
              </div>
              <div class="run-meta">
                <span class="tag task">${info.dataset_name || '—'}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Total Items</span>
                <span class="stat-val">${stats.total || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Completed</span>
                <span class="stat-val">${stats.completed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Failed</span>
                <span class="stat-val ${stats.failed > 0 ? 'low' : ''}">${stats.failed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Success Rate</span>
                <span class="stat-val ${successClass}">${formatPercent(successRate)}</span>
              </div>
            </div>
          `;
        }).join('');

        // Add click handlers for remove buttons
        container.querySelectorAll('.remove-run').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.target.dataset.idx, 10);
            removeRun(idx);
          });
        });
      }

      function renderMetricsTable() {
        const thead = el('metrics-thead');
        const tbody = el('metrics-tbody');

        // Header row
        thead.innerHTML = `
          <tr>
            <th>Metric</th>
            ${state.runs.map((run, idx) => {
              const info = run.run || {};
              const color = COLORS[idx % COLORS.length];
              return `<th><span style="display:inline-block;width:10px;height:10px;background:${color};border-radius:2px;margin-right:6px;"></span>${info.run_name || 'Run ' + (idx + 1)}</th>`;
            }).join('')}
          </tr>
        `;

        // Calculate metric averages and latency for each run
        const runMetricAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricNames = snap.metric_names || run.run?.metric_names || [];
          const avgs = {};

          for (const metric of state.allMetrics) {
            const idx = metricNames.indexOf(metric);
            if (idx === -1) {
              avgs[metric] = null;
              continue;
            }

            let sum = 0, count = 0;
            for (const row of rows) {
              // Use centralized error handling - errors count as 0
              const { score } = window.QymMetrics.getRowScore(row, idx);
              if (score !== null) {
                sum += score;
                count++;
              }
            }
            avgs[metric] = count > 0 ? sum / count : null;
          }
          return avgs;
        });

        // Calculate average latency for each run
        const runLatencyAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          let sum = 0, count = 0;
          for (const row of rows) {
            if (row.latency_ms && row.status === 'completed') {
              sum += row.latency_ms;
              count++;
            }
          }
          return count > 0 ? sum / count : null;
        });

        // Find best (lowest) latency
        const bestLatency = Math.min(...runLatencyAvgs.filter(v => v !== null));

        // Find best value for each metric
        const bestValues = {};
        for (const metric of state.allMetrics) {
          let best = -Infinity;
          for (const avgs of runMetricAvgs) {
            if (avgs[metric] !== null && avgs[metric] > best) {
              best = avgs[metric];
            }
          }
          bestValues[metric] = best > -Infinity ? best : null;
        }

        // Render rows - metrics first, then latency
        const metricRows = state.allMetrics.map(metric => {
          const cells = runMetricAvgs.map(avgs => {
            const val = avgs[metric];
            if (val === null) return '<td class="metric-val">—</td>';
            const isBest = val === bestValues[metric] && state.runs.length > 1;
            const cls = getSuccessClass(val);
            return `<td class="metric-val ${cls} ${isBest ? 'best' : ''}">${formatPercent(val)}</td>`;
          }).join('');

          return `
            <tr>
              <td class="metric-name">${metric}</td>
              ${cells}
            </tr>
          `;
        }).join('');

        // Latency row
        const latencyCells = runLatencyAvgs.map(val => {
          if (val === null) return '<td class="metric-val">—</td>';
          const isBest = val === bestLatency && state.runs.length > 1;
          return `<td class="metric-val ${isBest ? 'best' : ''}" style="${isBest ? 'background: var(--success-dim);' : ''}">${formatLatency(val)}</td>`;
        }).join('');

        const latencyRow = `
          <tr>
            <td class="metric-name">Avg Latency</td>
            ${latencyCells}
          </tr>
        `;

        tbody.innerHTML = metricRows + latencyRow;
      }

      function getFilteredItems() {
        // Build aligned item list across runs using item_id
        const items = [];
        const selectedMetric = state.selectedItemsMetric;
        const stats = selectedMetric ? state.comparisonStats[selectedMetric] : null;

        // Collect all unique item_ids across all runs for proper alignment
        const allItemIds = new Set();
        for (const run of state.runs) {
          const rows = run.snapshot?.rows || [];
          for (const row of rows) {
            const itemId = row.item_id || String(row.index);
            allItemIds.add(itemId);
          }
        }
        const itemIdList = Array.from(allItemIds);

        // Helper to get metric index for a run
        function getMetricIndex(run) {
          const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
          return selectedMetric ? metricNames.indexOf(selectedMetric) : 0;
        }

        for (const itemId of itemIdList) {
          const rowData = state.runs.map(run => {
            const rows = run.snapshot?.rows || [];
            // Match by item_id, fallback to index for legacy data
            return rows.find(r => (r.item_id || String(r.index)) === itemId) || null;
          });

          // Get scores for this item based on selected metric (use centralized error handling)
          const scores = rowData.map((row, runIdx) => {
            if (!row) return null;
            const run = state.runs[runIdx];
            const metricIdx = getMetricIndex(run);
            if (metricIdx < 0) return null;
            // Use centralized error handling from metrics.js
            const { score } = window.QymMetrics.getRowScore(row, metricIdx);
            return score;
          });
          const validScores = scores.filter(s => s !== null);

          // #19: Apply search query filter (on input/expected text)
          if (state.searchQuery) {
            const q = state.searchQuery.toLowerCase();
            const inputRow = rowData.find(r => r);
            const inputText = String(inputRow?.input_full || inputRow?.input || '').toLowerCase();
            const expectedText = String(inputRow?.expected_full || inputRow?.expected || '').toLowerCase();
            if (!inputText.includes(q) && !expectedText.includes(q)) continue;
          }

          // #2: Apply complexity/domain category filters (null = all, array = explicit)
          if (state.complexityFilter !== null || state.domainFilter !== null) {
            const inputRow = rowData.find(r => r);
            const md = (typeof (inputRow?.item_metadata) === 'object') ? inputRow.item_metadata : {};
            if (state.complexityFilter !== null) {
              if (state.complexityFilter.length === 0) continue;
              const val = String(md.complexity ?? '').toLowerCase();
              if (!state.complexityFilter.some(f => f.toLowerCase() === val)) continue;
            }
            if (state.domainFilter !== null) {
              if (state.domainFilter.length === 0) continue;
              const val = String(md.domain ?? '').toLowerCase();
              if (!state.domainFilter.some(f => f.toLowerCase() === val)) continue;
            }
          }

          // Apply item filter
          if (state.itemFilter === 'different') {
            const outputs = rowData.map(r => r?.output_full || r?.output || '').filter(o => o);
            const uniqueOutputs = new Set(outputs);
            if (uniqueOutputs.size <= 1) continue;
          } else if (state.itemFilter === 'errors') {
            const hasError = rowData.some(r => window.QymMetrics.isErrorRow(r));
            if (!hasError) continue;
          } else if (state.itemFilter === 'all_correct') {
            // All runs meet threshold (correct)
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            if (validScores.length < 2 || !validScores.every(s => s >= correctThreshold)) continue;
          } else if (state.itemFilter === 'all_wrong') {
            // No run meets threshold (not correct)
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            if (validScores.length < 2 || validScores.some(s => s >= correctThreshold)) continue;
          } else if (state.itemFilter === 'rarely_solved') {
            // 25% or fewer runs meet threshold
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            const numCorrect = scores.filter(s => s !== null && s >= correctThreshold).length;
            const rareThreshold = Math.max(1, Math.floor(state.runs.length * 0.25));
            if (numCorrect === 0 || numCorrect > rareThreshold) continue;
          } else if (state.itemFilter === 'unique_solve') {
            // Exactly 1 run meets threshold
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            const numCorrect = scores.filter(s => s !== null && s >= correctThreshold).length;
            if (numCorrect !== 1) continue;
          } else if (state.itemFilter === 'partially_correct') {
            // #12: Some but not all runs met threshold
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            const numCorrect = scores.filter(s => s !== null && s >= correctThreshold).length;
            if (numCorrect === 0 || numCorrect === validScores.length || validScores.length < 2) continue;
          }

          // #20: Apply pass rate filter
          if (state.passRateOp) {
            const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
            const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
            const numCorrect = scores.filter(s => s !== null && s >= correctThreshold).length;
            const target = state.passRateValue;
            if (state.passRateOp === 'lte' && numCorrect > target) continue;
            if (state.passRateOp === 'gte' && numCorrect < target) continue;
            if (state.passRateOp === 'eq' && numCorrect !== target) continue;
          }

          // Apply winner filter using item_id to index mapping
          if (state.winnerFilter !== 'any' && stats && state.itemIdToIndex) {
            const itemIndex = state.itemIdToIndex[itemId];
            const winner = itemIndex !== undefined ? stats.itemWinners[itemIndex] : null;
            if (state.winnerFilter === 'tie') {
              // Only show ties (all runs same score OR multiple tied for highest)
              if (winner !== 'tie') continue;
            } else if (state.winnerFilter.startsWith('win_')) {
              const winnerIdx = parseInt(state.winnerFilter.replace('win_', ''), 10);
              // Only show items where this run was the SOLE winner (beat all others)
              if (winner !== winnerIdx) continue;
            } else if (state.winnerFilter.startsWith('only_')) {
              // Only show items where ONLY this run met threshold
              const runIdx = parseInt(state.winnerFilter.replace('only_', ''), 10);
              const isBoolean = state.metricIsBoolean[state.selectedItemsMetric];
              const correctThreshold = isBoolean ? 0.9999 : state.metricThresholds[state.selectedItemsMetric];
              const correctRuns = scores.map((s, idx) => s !== null && s >= correctThreshold ? idx : -1).filter(x => x >= 0);
              if (correctRuns.length !== 1 || correctRuns[0] !== runIdx) continue;
            }
          }

          items.push({ itemId: itemId, rowData });
        }

        return items;
      }

      function renderItems(scrollToTop = false) {
        const container = el('items-grid');
        const paginationEl = el('pagination');
        const filterCountEl = el('filter-count');
        const items = getFilteredItems();

        // Update filter count & clear button
        filterCountEl.innerHTML = `Showing <span class="count-num">${items.length}</span> items`;
        updateClearButton();

        // Set CSS variable for grid columns
        container.style.setProperty('--run-count', state.runs.length);

        // Pagination
        const totalPages = Math.max(1, Math.ceil(items.length / state.pageSize));
        if (state.page > totalPages) state.page = totalPages;
        const start = (state.page - 1) * state.pageSize;
        const pageItems = items.slice(start, start + state.pageSize);

        if (items.length === 0) {
          container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);">No items match the current filter</div>';
          paginationEl.innerHTML = '';
          return;
        }

        container.innerHTML = pageItems.map(({ itemId, rowData }) => {
          // Get input and expected from any available row
          const inputRow = rowData.find(r => r);
          const input = inputRow?.input_full || inputRow?.input || '—';
          const expected = inputRow?.expected_full || inputRow?.expected || '';

          // Use a safe ID for DOM elements by encoding the itemId
          const safeId = btoa(itemId).replace(/[+/=]/g, '_');

          const outputCells = rowData.map((row, runIdx) => {
            const color = COLORS[runIdx % COLORS.length];
            const runInfo = state.runs[runIdx]?.run || {};

            if (!row) {
              return `
                <div class="item-run-output" style="border-left-color: ${color}">
                  <div class="output-header">
                    <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)}</span>
                  </div>
                  <div class="output-text" style="color:var(--text-muted);font-style:italic;">No data</div>
                </div>
              `;
            }

            const output = row.output_full || row.output || '—';
            const status = row.status || 'pending';
            const latencyMs = row.latency_ms;
            const taskStartedAtMs = row.task_started_at_ms;
            const traceId = row.trace_id;
            // Use direct trace_url if available, otherwise build from trace_id (global or per-run config)
            const traceUrl = row.trace_url || buildLangfuseTraceUrl(traceId) || buildLangfuseTraceUrlFromRun(traceId, runInfo);

            // Get metric values and metadata
            const metricVals = row.metric_values || [];
            const metricMeta = row.metric_meta || {};
            const run = state.runs[runIdx];
            const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];

            // Determine if this run is the winner for the selected metric
            const selectedMetric = state.selectedItemsMetric;
            const stats = selectedMetric ? state.comparisonStats[selectedMetric] : null;
            // Use itemIdToIndex mapping to find the winner for this item
            const itemIndex = state.itemIdToIndex?.[itemId];
            const itemWinner = itemIndex !== undefined ? stats?.itemWinners?.[itemIndex] : null;
            const isWinner = itemWinner === runIdx;

            // Build inline metric scores (all metrics shown, selected one highlighted)
            const metricScoresHtml = metricNames.map((name, i) => {
              const score = metricVals[i];
              const v = window.QymMetrics.parseScoreValue(score);
              if (v === null) return '';

              const cls = getSuccessClass(v);
              const isSelected = name === selectedMetric;
              const meta = metricMeta[name] || {};
              const editBtn = `<button class="metric-edit-open" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}" aria-label="Edit ${escapeAttr(name)}" title="Edit">✎</button>`;
              const editedBadge = String(meta.modified || '').toLowerCase() === 'true'
                ? '<span class="metric-edit-badge">Edited</span>'
                : '';

              return `<div class="metric-score-row ${isSelected ? 'highlighted' : ''}">
                <span class="metric-score-name">${escapeHtml(name)}</span>
                <span class="metric-score-meta">
                  <span class="metric-score-value ${cls}">${formatPercent(v)}</span>
                  ${editBtn}
                  ${editedBadge}
                </span>
              </div>`;
            }).join('');

            let metricEditHtml = '';
            if (metricNames.length) {
              metricEditHtml = metricNames.map((name, i) => {
                const rawScore = metricVals[i];
                const rawValue = (rawScore == null || rawScore === '') ? '' : String(rawScore);
                const meta = metricMeta[name] || {};
                const originalRaw = meta.original_score;
                const hasOriginal = !(originalRaw == null || originalRaw === '');
                const modifiedNote = hasOriginal
                  ? `<div class="metric-edit-meta">Original: ${escapeHtml(String(originalRaw))}</div>`
                  : '';
                return `
                  <div class="metric-edit-block hidden" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}">
                    <div class="metric-edit-title">Edit ${escapeHtml(name)}_score</div>
                    <div class="metric-edit-controls">
                      <input class="metric-edit-input" type="text" value="${escapeAttr(rawValue)}" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}" />
                      <button class="metric-edit-save" data-run-idx="${runIdx}" data-row-index="${escapeAttr(String(row.index ?? 0))}" data-metric="${escapeAttr(name)}">Save</button>
                      <span class="metric-edit-status" aria-live="polite"></span>
                    </div>
                    ${modifiedNote}
                  </div>
                `;
              }).join('');
            }

            // Latency badge
            const latencyBadge = latencyMs ? `<span class="latency-badge">${formatLatency(latencyMs)}</span>` : '';

            // Task start badge (local time)
            const startInfo = formatTaskStart(taskStartedAtMs);
            const startBadge = startInfo
              ? `<span class="start-badge" title="${escapeAttr(startInfo.ts)}">${escapeHtml(startInfo.ts)}</span>`
              : '';

            // Langfuse trace link
            const traceLink = traceUrl ? `<a href="${traceUrl}" target="_blank" class="trace-link" title="View trace in Langfuse">Langfuse ↗</a>` : '';

            // Build metric details for this run (hidden by default, controlled by shared toggle)
            let metricDetailsHtml = '';
            const hasMetricMeta = Object.keys(metricMeta).length > 0;

            if (hasMetricMeta) {
              const detailRows = metricNames.map((name) => {
                const meta = metricMeta[name] || {};
                const metaKeys = Object.keys(meta).filter(k => !['modified','original_score'].includes(k));
                if (metaKeys.length === 0) return '';

                return metaKeys.map(key => {
                  const val = meta[key];
                  if (val === undefined || val === null || val === '') return '';
                  const displayName = formatFieldName(key);
                  return `<div class="metric-detail-row">
                    <span class="metric-detail-name">${escapeHtml(name)} · ${displayName}</span>
                    <span class="metric-detail-value">${escapeHtml(String(val))}</span>
                  </div>`;
                }).join('');
              }).join('');

              if (detailRows) {
                metricDetailsHtml = `
                  <div class="run-metric-details" data-item="${safeId}">
                    ${detailRows}
                  </div>
                `;
              }
            }

            const winnerBadge = isWinner ? '<span class="winner-badge">★ Winner</span>' : '';
            return `
              <div class="item-run-output" style="border-left-color: ${color}">
                <div class="output-header">
                  <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)} ${winnerBadge}</span>
                  <span class="output-badges"><button class="copy-btn" data-copy-text="${escapeAttr(typeof output === 'object' ? JSON.stringify(output, null, 2) : String(output))}" title="Copy output">${COPY_ICON}</button>${startBadge}${latencyBadge}${traceLink}</span>
                </div>
                <div class="output-text ${status === 'error' ? 'low' : ''}">${renderMarkdownSafe(output)}</div>
                <div class="metric-scores-inline">${metricScoresHtml}</div>
                ${metricEditHtml}
                ${metricDetailsHtml}
              </div>
            `;
          }).join('');

          // Build shared metric details section (all runs' metadata in one expandable area)
          const metricDetailsHtml = buildMetricDetailsSection(itemId, rowData);

          // Format item ID for display (e.g., "item_5" -> "Item 6", or keep original if not matching pattern)
          let displayItemId = itemId;
          const itemMatch = itemId.match(/^item_(\d+)$/);
          if (itemMatch) {
            displayItemId = `Item ${parseInt(itemMatch[1], 10) + 1}`;
          }

          // #5/#6: Build item metadata row — complexity & domain as first-class badges
          let itemMetadataHtml = '';
          {
            const SPECIAL_KEYS = ['complexity', 'domain'];
            const metaRow = rowData.find(r => r);
            const md = metaRow?.item_metadata || {};
            if (typeof md === 'object') {
              // Build special badges for complexity & domain
              let badgesHtml = '';
              for (const sk of SPECIAL_KEYS) {
                if (md[sk] !== undefined && md[sk] !== null && md[sk] !== '' && state.visibleMetadataFields[sk] !== false) {
                  const icon = sk === 'complexity' ? '\u2666' : '\u25C6';
                  // Add value-specific color class for complexity
                  let valClass = '';
                  if (sk === 'complexity') {
                    const v = String(md[sk]).toLowerCase().trim();
                    if (['easy', 'simple', 'basic', 'low'].includes(v)) valClass = ' complexity-easy';
                    else if (['medium', 'moderate', 'intermediate', 'mid'].includes(v)) valClass = ' complexity-medium';
                    else if (['hard', 'difficult', 'advanced', 'high'].includes(v)) valClass = ' complexity-hard';
                    else if (['very hard', 'very_hard', 'expert', 'extreme'].includes(v)) valClass = ' complexity-expert';
                  }
                  badgesHtml += `<span class="meta-badge badge-${sk}${valClass}"><span class="badge-icon">${icon}</span>${escapeHtml(String(md[sk]))}</span>`;
                }
              }

              // Build generic tags (everything except special keys and internal keys)
              const genericEntries = Object.entries(md).filter(([k]) =>
                k !== 'task_started_at_ms' && !SPECIAL_KEYS.includes(k) && state.visibleMetadataFields[k] !== false
              );
              let genericHtml = '';
              if (genericEntries.length > 0) {
                genericHtml = genericEntries.map(([k, v]) =>
                  `<span class="item-metadata-tag"><span class="meta-key">${escapeHtml(k)}:</span> <span class="meta-val">${escapeHtml(String(v))}</span></span>`
                ).join('');
              }

              if (badgesHtml || genericHtml) {
                const separator = badgesHtml && genericHtml ? '<span class="item-meta-sep"></span>' : '';
                itemMetadataHtml = `
                  <div class="item-metadata-row">
                    ${badgesHtml ? `<div class="item-meta-badges">${badgesHtml}</div>` : ''}
                    ${separator}
                    ${genericHtml ? `<div class="item-metadata-tags">${genericHtml}</div>` : ''}
                  </div>`;
              }
            }
          }

          return `
            <div class="item-comparison-row">
              <div class="item-header">
                <span class="item-index" title="ID: ${escapeHtml(itemId)}">${escapeHtml(displayItemId)}</span>
                <button class="copy-btn" data-item-id="${escapeAttr(itemId)}" title="Copy all fields">${COPY_ICON}</button>
              </div>
              <div class="item-input-row">
                <div class="input-label">Input <button class="copy-btn" data-copy-text="${escapeAttr(typeof input === 'object' ? JSON.stringify(input, null, 2) : String(input))}" title="Copy input">${COPY_ICON}</button></div>
                <div class="input-text">${renderMarkdownSafe(input)}</div>
              </div>
              ${expected ? `
              <div class="item-expected-row">
                <div class="expected-label">Expected Output <button class="copy-btn" data-copy-text="${escapeAttr(typeof expected === 'object' ? JSON.stringify(expected, null, 2) : String(expected))}" title="Copy expected output">${COPY_ICON}</button></div>
                <div class="expected-text">${renderMarkdownSafe(expected)}</div>
              </div>` : ''}
              ${itemMetadataHtml}
              <div class="item-outputs-row" style="--run-count: ${state.runs.length}">
                ${outputCells}
              </div>
              ${metricDetailsHtml}
            </div>
          `;
        }).join('');

        // Pagination controls
        paginationEl.innerHTML = `
          <button id="prev-page" ${state.page <= 1 ? 'disabled' : ''}>← Prev</button>
          <span class="page-info">Page ${state.page} of ${totalPages}</span>
          <button id="next-page" ${state.page >= totalPages ? 'disabled' : ''}>Next →</button>
        `;

        el('prev-page').onclick = () => { state.page--; renderItems(true); };
        el('next-page').onclick = () => { state.page++; renderItems(true); };

        // Scroll to top of items grid if requested
        if (scrollToTop) {
          container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        wireMetricEditHandlers();
        alignOutputHeights();

        // #16: Wire copy-all buttons (per item — header icon)
        container.querySelectorAll('.copy-btn[data-item-id]').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = btn.dataset.itemId;
            const item = getFilteredItems().find(it => it.itemId === id);
            if (!item) return;
            const inputRow = item.rowData.find(r => r);
            const parts = [];
            const inp = inputRow?.input_full || inputRow?.input || '';
            parts.push('Input: ' + (typeof inp === 'object' ? JSON.stringify(inp, null, 2) : String(inp)));
            const exp = inputRow?.expected_full || inputRow?.expected || '';
            if (exp) parts.push('Expected: ' + (typeof exp === 'object' ? JSON.stringify(exp, null, 2) : String(exp)));
            item.rowData.forEach((rd, ri) => {
              const rName = state.runs[ri]?.run?.run_name || `Run ${ri + 1}`;
              const out = rd?.output_full || rd?.output || '';
              parts.push(`${rName} Output: ${typeof out === 'object' ? JSON.stringify(out, null, 2) : String(out)}`);
            });
            navigator.clipboard.writeText(parts.join('\n\n')).then(() => {
              btn.innerHTML = CHECK_ICON;
              btn.classList.add('copied');
              setTimeout(() => { btn.innerHTML = COPY_ICON; btn.classList.remove('copied'); }, 1500);
            });
          });
        });

        // #16: Wire all data-copy-text buttons (input, expected, output, per-field)
        container.querySelectorAll('.copy-btn[data-copy-text]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            navigator.clipboard.writeText(btn.dataset.copyText).then(() => {
              btn.innerHTML = CHECK_ICON;
              btn.classList.add('copied');
              setTimeout(() => { btn.innerHTML = COPY_ICON; btn.classList.remove('copied'); }, 1500);
            });
          });
        });
      }

      // #4: Safe markdown rendering (basic inline markdown: bold, italic, code, links)
      function renderMarkdownSafe(value) {
        if (value === null || value === undefined) return '—';
        if (typeof value === 'object') return formatObjectAsHtml(value);
        const str = String(value);
        // Check if it looks like a structured object first
        const trimmed = str.trim();
        if ((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
            (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'object' && parsed !== null) return formatObjectAsHtml(parsed);
          } catch {}
          const parsed = parsePythonDict(trimmed);
          if (parsed !== null) return formatObjectAsHtml(parsed);
        }
        // Apply basic markdown transforms (safe subset - no raw HTML)
        let html = escapeHtml(str);
        // Code blocks (triple backtick)
        html = html.replace(/```([\s\S]*?)```/g, '<pre style="background:var(--bg-elevated);padding:4px 8px;border-radius:4px;overflow-x:auto;margin:4px 0;">$1</pre>');
        // Inline code
        html = html.replace(/`([^`]+)`/g, '<code style="background:var(--bg-elevated);padding:1px 4px;border-radius:3px;">$1</code>');
        // Bold
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        // Italic
        html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
        // Links
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color:var(--accent-primary);">$1</a>');
        return html;
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
      }
      const COPY_ICON = '<svg viewBox="0 0 24 24" fill="none" stroke="#9898a8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
      const CHECK_ICON = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';

      function escapeAttr(text) {
        return String(text ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function alignOutputHeights() {
        try {
          const rows = document.querySelectorAll('.item-outputs-row');
          rows.forEach(row => {
            const outputs = row.querySelectorAll('.item-run-output .output-text');
            if (!outputs.length) return;
            outputs.forEach(el => { el.style.minHeight = '0px'; });
            let max = 0;
            outputs.forEach(el => {
              const h = el.scrollHeight || el.offsetHeight || 0;
              if (h > max) max = h;
            });
            outputs.forEach(el => { el.style.minHeight = `${max}px`; });
          });
        } catch {}
      }

      async function updateMetricScore(filePath, rowIndex, metricName, newScore) {
        const res = await fetch(apiUrl('api/runs/update_metric'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            file_path: filePath,
            row_index: rowIndex,
            metric_name: metricName,
            new_score: newScore,
          }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.error) {
          throw new Error(data.error || 'Failed to update metric');
        }
        return data;
      }

      function applyUpdatedRowToRun(runIdx, updatedRow) {
        try {
          const run = state.runs[runIdx];
          if (!run || !run.snapshot) return;
          const rows = run.snapshot.rows || [];
          const idx = Number(updatedRow.index) || 0;
          if (idx >= 0 && idx < rows.length) {
            rows[idx] = updatedRow;
          } else {
            const pos = rows.findIndex(r => Number(r.index) === idx);
            if (pos >= 0) rows[pos] = updatedRow;
          }
        } catch {}
      }

      function refreshComparisonStatsAfterEdit() {
        // Recalculate stats for ALL metrics (the edit may affect any of them)
        for (const metricName of state.allMetrics) {
          state.comparisonStats[metricName] = calculateComparisonStatsForMetric(metricName);
        }
        renderComparisonStats();
        renderMetricsTable();
        renderSummaries();
      }

      function wireMetricEditHandlers() {
        document.querySelectorAll('.metric-edit-open').forEach(btn => {
          btn.onclick = () => {
            const runIdx = btn.dataset.runIdx;
            const rowIndex = btn.dataset.rowIndex;
            const metric = btn.dataset.metric;
            const block = document.querySelector(`.metric-edit-block[data-run-idx="${runIdx}"][data-row-index="${rowIndex}"][data-metric="${metric}"]`);
            if (!block) return;
            const isHidden = block.classList.contains('hidden');
            block.classList.toggle('hidden');
            btn.textContent = isHidden ? '✕' : '✎';
            btn.setAttribute('title', isHidden ? 'Close' : 'Edit');
            btn.setAttribute('aria-label', isHidden ? 'Close edit' : 'Edit');
          };
        });
        document.querySelectorAll('.metric-edit-save').forEach(btn => {
          btn.onclick = async () => {
            const runIdx = Number(btn.dataset.runIdx);
            const rowIndex = Number(btn.dataset.rowIndex);
            const metricName = btn.dataset.metric || '';
            const controls = btn.closest('.metric-edit-controls');
            const input = controls ? controls.querySelector('.metric-edit-input') : null;
            const status = controls ? controls.querySelector('.metric-edit-status') : null;
            const run = state.runs[runIdx];
            const filePath = run?.run?.file_path || '';
            if (!filePath || !metricName || !input) {
              if (status) status.textContent = 'Unavailable';
              return;
            }
            btn.disabled = true;
            if (status) status.textContent = 'Saving...';
            try {
              const result = await updateMetricScore(filePath, rowIndex, metricName, input.value);
              if (result && result.row) {
                applyUpdatedRowToRun(runIdx, result.row);
                refreshComparisonStatsAfterEdit();
                renderItems();
              }
            } catch (err) {
              if (status) status.textContent = 'Error';
            } finally {
              btn.disabled = false;
              if (status && status.textContent === 'Saving...') status.textContent = '';
            }
          };
        });
      }

      // Global function for toggling all metric details for an item
      window.toggleItemMetricDetails = function(itemIndex) {
        const details = document.querySelectorAll(`.run-metric-details[data-item="${itemIndex}"]`);
        const icon = document.getElementById(`toggle-icon-${itemIndex}`);

        if (details.length === 0) return;

        const isExpanded = details[0].classList.contains('expanded');

        details.forEach(detail => {
          if (isExpanded) {
            detail.classList.remove('expanded');
          } else {
            detail.classList.add('expanded');
          }
        });

        if (icon) {
          icon.textContent = isExpanded ? '▶' : '▼';
        }
      };

      // Format field names to be more readable
      function formatFieldName(name) {
        // Remove common prefixes and convert to title case
        return name
          .replace(/_/g, ' ')
          .replace(/\b\w/g, c => c.toUpperCase());
      }

      // Build shared toggle button for metric details (controls all runs' details for this item)
      function buildMetricDetailsSection(itemId, rowData) {
        // Check if any run has metadata
        const hasAnyMeta = rowData.some(row => {
          if (!row) return false;
          const metricMeta = row.metric_meta || {};
          return Object.keys(metricMeta).some(metric => {
            const meta = metricMeta[metric] || {};
            return Object.keys(meta).length > 0;
          });
        });

        if (!hasAnyMeta) return '';

        // Use a safe ID for DOM elements by encoding the itemId
        const safeId = btoa(itemId).replace(/[+/=]/g, '_');

        return `
          <div class="item-metric-details-toggle">
            <button class="metric-details-toggle" onclick="toggleItemMetricDetails('${safeId}')">
              <span class="toggle-icon" id="toggle-icon-${safeId}">▶</span> Metric Details
            </button>
          </div>
        `;
      }

      function formatValue(value) {
        // Handle null/undefined
        if (value === null || value === undefined) {
          return '—';
        }

        // If it's already a string, check if it's a JSON string or Python dict repr
        if (typeof value === 'string') {
          const trimmed = value.trim();

          // Try to parse as JSON first
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'object' && parsed !== null) {
              return formatObjectAsHtml(parsed);
            }
          } catch {
            // Not valid JSON, continue to try Python dict repr
          }

          // Try to handle Python dict repr (single quotes, True/False/None)
          if ((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
              (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
            const parsed = parsePythonDict(trimmed);
            if (parsed !== null) {
              return formatObjectAsHtml(parsed);
            }
          }

          return escapeHtml(value);
        }

        // If it's an object or array, format it nicely
        if (typeof value === 'object') {
          return formatObjectAsHtml(value);
        }

        // For other primitives, just convert to string
        return escapeHtml(String(value));
      }

      function parsePythonDict(str) {
        // Parse Python dict repr like {'key': 'value', 'num': 123, 'bool': True}
        // This is a simple parser that handles common cases
        try {
          let i = 0;
          const len = str.length;

          function skipWhitespace() {
            while (i < len && /\s/.test(str[i])) i++;
          }

          function parseValue() {
            skipWhitespace();
            if (i >= len) return undefined;

            const ch = str[i];

            // String (single or double quoted)
            if (ch === "'" || ch === '"') {
              return parseString(ch);
            }
            // Object
            if (ch === '{') {
              return parseObject();
            }
            // Array
            if (ch === '[') {
              return parseArray();
            }
            // Number, boolean, None
            return parseLiteral();
          }

          function parseString(quote) {
            i++; // skip opening quote
            let result = '';
            while (i < len) {
              const ch = str[i];
              if (ch === '\\' && i + 1 < len) {
                // Handle escape sequences
                const next = str[i + 1];
                if (next === 'n') { result += '\n'; i += 2; }
                else if (next === 't') { result += '\t'; i += 2; }
                else if (next === 'r') { result += '\r'; i += 2; }
                else if (next === '\\') { result += '\\'; i += 2; }
                else if (next === quote) { result += quote; i += 2; }
                else { result += ch; i++; }
              } else if (ch === quote) {
                i++; // skip closing quote
                return result;
              } else {
                result += ch;
                i++;
              }
            }
            return result; // unclosed string
          }

          function parseObject() {
            i++; // skip '{'
            const obj = {};
            skipWhitespace();
            if (str[i] === '}') { i++; return obj; }

            while (i < len) {
              skipWhitespace();
              // Parse key (must be string)
              const key = parseValue();
              if (typeof key !== 'string') return null;

              skipWhitespace();
              if (str[i] !== ':') return null;
              i++; // skip ':'

              // Parse value
              const val = parseValue();
              obj[key] = val;

              skipWhitespace();
              if (str[i] === '}') { i++; return obj; }
              if (str[i] === ',') { i++; continue; }
              return null; // unexpected character
            }
            return obj;
          }

          function parseArray() {
            i++; // skip '['
            const arr = [];
            skipWhitespace();
            if (str[i] === ']') { i++; return arr; }

            while (i < len) {
              const val = parseValue();
              arr.push(val);

              skipWhitespace();
              if (str[i] === ']') { i++; return arr; }
              if (str[i] === ',') { i++; continue; }
              return null;
            }
            return arr;
          }

          function parseLiteral() {
            // Check for True, False, None, or numbers
            if (str.slice(i, i + 4) === 'True') { i += 4; return true; }
            if (str.slice(i, i + 5) === 'False') { i += 5; return false; }
            if (str.slice(i, i + 4) === 'None') { i += 4; return null; }

            // Parse number
            let numStr = '';
            while (i < len && /[0-9.\-+eE]/.test(str[i])) {
              numStr += str[i];
              i++;
            }
            if (numStr) {
              const num = parseFloat(numStr);
              if (!isNaN(num)) return num;
            }
            return undefined;
          }

          const result = parseValue();
          return result;
        } catch {
          return null;
        }
      }

      function formatObjectAsHtml(obj) {
        if (Array.isArray(obj)) {
          // Format arrays
          if (obj.length === 0) return '<span class="formatted-array">[]</span>';
          const items = obj.map((item, idx) => {
            let formattedItem;
            if (item === null || item === undefined) {
              formattedItem = '<span class="formatted-null">null</span>';
            } else if (typeof item === 'object') {
              formattedItem = formatObjectAsHtml(item);
            } else if (typeof item === 'string') {
              formattedItem = `<span class="formatted-string">${escapeHtml(item)}</span>`;
            } else {
              formattedItem = escapeHtml(String(item));
            }
            return `<div class="formatted-array-item"><span class="formatted-index">[${idx}]</span> ${formattedItem}</div>`;
          }).join('');
          return `<div class="formatted-array">${items}</div>`;
        }

        // Format objects as key-value pairs
        const entries = Object.entries(obj);
        if (entries.length === 0) return '<span class="formatted-object">{}</span>';

        const rows = entries.map(([key, val]) => {
          let formattedVal;
          if (val === null || val === undefined) {
            formattedVal = '<span class="formatted-null">null</span>';
          } else if (typeof val === 'object') {
            formattedVal = formatObjectAsHtml(val);
          } else if (typeof val === 'string') {
            // Show full string without quotes
            formattedVal = `<span class="formatted-string">${escapeHtml(val)}</span>`;
          } else if (typeof val === 'number') {
            formattedVal = `<span class="formatted-number">${val}</span>`;
          } else if (typeof val === 'boolean') {
            formattedVal = `<span class="formatted-boolean">${val}</span>`;
          } else {
            formattedVal = escapeHtml(String(val));
          }
          const copyVal = String(val ?? '');
          return `<div class="formatted-row"><span class="formatted-key">${escapeHtml(key)}</span>${formattedVal}<button class="copy-btn" data-copy-text="${escapeAttr(copyVal)}" title="Copy ${escapeHtml(key)}">${COPY_ICON}</button></div>`;
        }).join('');

        return `<div class="formatted-object">${rows}</div>`;
      }

      // ── Clear button counter ──
      function countActiveFilters() {
        let n = 0;
        if (state.itemFilter !== 'all') n++;
        if (state.winnerFilter !== 'any') n++;
        if (state.searchQuery) n++;
        if (state.complexityFilter !== null) n++;
        if (state.domainFilter !== null) n++;
        if (state.passRateOp) n++;
        return n;
      }

      function updateClearButton() {
        const clearBtn = el('clear-all-btn');
        const countBadge = el('active-filter-count');
        const n = countActiveFilters();
        if (clearBtn) clearBtn.classList.toggle('visible', n > 0);
        if (countBadge) countBadge.textContent = n;
      }

      function clearAllFilters() {
        state.itemFilter = 'all';
        state.winnerFilter = 'any';
        state.searchQuery = '';
        state.complexityFilter = null;
        state.domainFilter = null;
        state.passRateOp = '';
        state.passRateValue = 0;
        state.page = 1;

        el('item-filter').value = 'all';
        el('run-winner-filter').value = 'any';
        el('items-search').value = '';
        el('pass-rate-op').value = '';
        el('pass-rate-value').style.display = 'none';
        el('pass-rate-suffix').style.display = 'none';
        syncMultiselectUI('complexity');
        syncMultiselectUI('domain');

        renderItems();
      }

      el('clear-all-btn').addEventListener('click', clearAllFilters);

      // Event listeners
      el('item-filter').addEventListener('change', (e) => {
        state.itemFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      el('run-winner-filter').addEventListener('change', (e) => {
        state.winnerFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      // #19: Search input with debounce
      {
        let searchTimer = null;
        el('items-search').addEventListener('input', (e) => {
          clearTimeout(searchTimer);
          searchTimer = setTimeout(() => {
            state.searchQuery = e.target.value.trim();
            state.page = 1;
            renderItems();
          }, 250);
        });
      }

      // #2: Category multi-select dropdowns for complexity & domain
      function buildCategoryDropdowns() {
        const hasComplexity = state.complexityValues.length > 0;
        const hasDomain = state.domainValues.length > 0;
        const hasMeta = hasComplexity || hasDomain;

        el('fp-cat-complexity').style.display = hasComplexity ? '' : 'none';
        el('fp-cat-domain').style.display = hasDomain ? '' : 'none';
        el('fp-meta-fields').style.display = hasMeta ? '' : 'none';

        if (hasComplexity) buildMultiselectOptions('complexity', state.complexityValues);
        if (hasDomain) buildMultiselectOptions('domain', state.domainValues);
      }

      function buildMultiselectOptions(category, values) {
        const dropdown = el(category + '-ms-dropdown');
        if (!dropdown) return;

        // Count unique items per value (from first run to avoid double-counting)
        const itemCounts = {};
        for (const v of values) itemCounts[v] = 0;
        if (state.runs.length > 0) {
          const rows = state.runs[0].snapshot?.rows || [];
          for (const row of rows) {
            const md = row.item_metadata || {};
            const val = String(md[category] ?? '');
            if (itemCounts[val] !== undefined) itemCounts[val]++;
          }
        }

        let html = values.map(v =>
          `<label class="multi-select-option" data-value="${escapeAttr(v)}">
            <input type="checkbox" data-cat="${escapeAttr(category)}" data-val="${escapeAttr(v)}" />
            <span>${escapeHtml(v)}</span>
            <span class="option-count">${itemCounts[v] || 0}</span>
          </label>`
        ).join('');

        html += `<div class="ms-actions">
          <button class="ms-action-btn" data-action="all" data-cat="${escapeAttr(category)}">Select All</button>
          <button class="ms-action-btn" data-action="none" data-cat="${escapeAttr(category)}">Clear</button>
        </div>`;

        dropdown.innerHTML = html;

        // Wire up option clicks
        dropdown.querySelectorAll('.multi-select-option input[type="checkbox"]').forEach(cb => {
          cb.addEventListener('change', () => {
            const val = cb.dataset.val;
            let filterArr = category === 'complexity' ? state.complexityFilter : state.domainFilter;
            // If null (= all), expand to explicit list before toggling
            if (filterArr === null) {
              filterArr = [...values];
              if (category === 'complexity') state.complexityFilter = filterArr;
              else state.domainFilter = filterArr;
            }
            if (cb.checked) {
              if (!filterArr.includes(val)) filterArr.push(val);
            } else {
              const idx = filterArr.indexOf(val);
              if (idx >= 0) filterArr.splice(idx, 1);
            }
            syncMultiselectUI(category);
            state.page = 1;
            renderItems();
          });
        });

        // Wire up actions
        dropdown.querySelectorAll('.ms-action-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (btn.dataset.action === 'all') {
              if (category === 'complexity') state.complexityFilter = null;
              else state.domainFilter = null;
            } else {
              if (category === 'complexity') state.complexityFilter = [];
              else state.domainFilter = [];
            }
            syncMultiselectUI(category);
            state.page = 1;
            renderItems();
          });
        });

        syncMultiselectUI(category);
      }

      function syncMultiselectUI(category) {
        const filterArr = category === 'complexity' ? state.complexityFilter : state.domainFilter;
        const values = category === 'complexity' ? state.complexityValues : state.domainValues;
        const defaultLabel = category === 'complexity' ? 'All Complexity' : 'All Domains';
        const btn = el(category + '-ms-btn');
        const dropdown = el(category + '-ms-dropdown');

        // Normalize: explicitly selecting every value = reset to null (no filter)
        if (filterArr !== null && filterArr.length === values.length) {
          if (category === 'complexity') state.complexityFilter = null;
          else state.domainFilter = null;
        }

        const effective = category === 'complexity' ? state.complexityFilter : state.domainFilter;

        // Update button text
        if (btn) {
          if (effective === null) {
            btn.textContent = defaultLabel;
            btn.classList.remove('has-selection');
          } else if (effective.length === 0) {
            btn.textContent = 'None';
            btn.classList.add('has-selection');
          } else if (effective.length === 1) {
            btn.textContent = effective[0];
            btn.classList.add('has-selection');
          } else {
            btn.textContent = effective.length + ' selected';
            btn.classList.add('has-selection');
          }
        }

        // Sync checkboxes: null = all checked, array = only those in array
        if (dropdown) {
          dropdown.querySelectorAll('.multi-select-option input[type="checkbox"]').forEach(cb => {
            cb.checked = effective === null || effective.includes(cb.dataset.val);
          });
        }
      }

      // Toggle dropdown open/close — reuse same pattern as index.html model filter
      function setupCatDropdownToggle(category) {
        const btn = el(category + '-ms-btn');
        const dropdown = el(category + '-ms-dropdown');
        if (!btn || !dropdown) return;

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          // Close other open dropdowns
          document.querySelectorAll('.multi-select-dropdown.open').forEach(d => {
            if (d !== dropdown) d.classList.remove('open');
          });
          dropdown.classList.toggle('open');
        });

        dropdown.addEventListener('click', (e) => e.stopPropagation());
      }

      setupCatDropdownToggle('complexity');
      setupCatDropdownToggle('domain');

      // Close dropdowns on outside click
      document.addEventListener('click', () => {
        document.querySelectorAll('.fp-cat-group .multi-select-dropdown.open').forEach(d => d.classList.remove('open'));
      });

      // #20: Pass rate filter — sentence-style controls
      el('pass-rate-op').addEventListener('change', (e) => {
        state.passRateOp = e.target.value;
        const show = !!e.target.value;
        el('pass-rate-value').style.display = show ? '' : 'none';
        el('pass-rate-suffix').style.display = show ? '' : 'none';
        if (show && !state.passRateValue) {
          state.passRateValue = Math.ceil(state.runs.length / 2);
          el('pass-rate-value').value = state.passRateValue;
        }
        state.page = 1;
        renderItems();
      });
      el('pass-rate-value').addEventListener('input', (e) => {
        const K = state.runs.length;
        let v = parseInt(e.target.value, 10);
        if (isNaN(v)) v = 0;
        if (v < 0) v = 0;
        if (v > K) v = K;
        state.passRateValue = v;
        state.page = 1;
        renderItems();
      });

      // #6: Metadata fields selector toggle
      el('metadata-fields-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const dropdown = el('metadata-fields-dropdown');
        dropdown.classList.toggle('open');
      });
      document.addEventListener('click', () => {
        el('metadata-fields-dropdown').classList.remove('open');
      });
      el('metadata-fields-dropdown').addEventListener('click', (e) => {
        e.stopPropagation();
      });

      function populateMetadataFieldsDropdown() {
        const dropdown = el('metadata-fields-dropdown');
        if (!dropdown || state.allMetadataKeys.length === 0) {
          if (dropdown) dropdown.innerHTML = '<div style="padding:4px;color:var(--text-muted);font-size:var(--font-xs);">No metadata fields found</div>';
          return;
        }
        dropdown.innerHTML = state.allMetadataKeys.map(k => {
          const checked = state.visibleMetadataFields[k] ? 'checked' : '';
          return `<label><input type="checkbox" ${checked} data-meta-key="${escapeAttr(k)}" /> ${escapeHtml(k)}</label>`;
        }).join('');
        dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          cb.addEventListener('change', () => {
            state.visibleMetadataFields[cb.dataset.metaKey] = cb.checked;
            renderItems();
          });
        });
      }

      // #8: Export filtered items as CSV
      el('export-filtered-btn').addEventListener('click', () => {
        const items = getFilteredItems();
        if (items.length === 0) return;
        const runNames = state.runs.map((r, i) => r.run?.run_name || `Run ${i + 1}`);
        const metricNames = state.allMetrics;
        // Build CSV header
        let header = ['item_id', 'input', 'expected'];
        for (let ri = 0; ri < state.runs.length; ri++) {
          header.push(`${runNames[ri]}_output`);
          for (const m of metricNames) {
            header.push(`${runNames[ri]}_${m}`);
          }
        }
        const csvRows = [header.join(',')];
        for (const { itemId, rowData } of items) {
          const inputRow = rowData.find(r => r);
          const input = inputRow?.input_full || inputRow?.input || '';
          const expected = inputRow?.expected_full || inputRow?.expected || '';
          const row = [csvEscape(itemId), csvEscape(stringify(input)), csvEscape(stringify(expected))];
          for (let ri = 0; ri < state.runs.length; ri++) {
            const rd = rowData[ri];
            const output = rd?.output_full || rd?.output || '';
            row.push(csvEscape(stringify(output)));
            const run = state.runs[ri];
            const mNames = run.snapshot?.metric_names || run.run?.metric_names || [];
            for (const m of metricNames) {
              const mIdx = mNames.indexOf(m);
              const score = mIdx >= 0 ? (rd?.metric_values || [])[mIdx] : '';
              row.push(csvEscape(String(score ?? '')));
            }
          }
          csvRows.push(row.join(','));
        }
        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'compare_export.csv';
        a.click();
        URL.revokeObjectURL(url);
      });

      function stringify(val) {
        if (val === null || val === undefined) return '';
        if (typeof val === 'object') return JSON.stringify(val);
        return String(val);
      }

      function csvEscape(val) {
        if (val.includes(',') || val.includes('"') || val.includes('\n')) {
          return '"' + val.replace(/"/g, '""') + '"';
        }
        return val;
      }

      // Initialize
      loadComparisonData();
    })();
  </script>
</body>
</html>
