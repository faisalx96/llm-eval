<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLM-Eval • Compare Runs</title>
  <link rel="stylesheet" href="/static/dashboard.css">
  <style>
    /* Compare-specific styles */
    .compare-container {
      padding: var(--space-lg);
      overflow-y: auto;
      height: calc(100vh - 100px);
    }

    .compare-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-md);
      border-bottom: 1px solid var(--border-default);
    }

    .compare-title {
      font-size: var(--font-lg);
      font-weight: 600;
      color: var(--text-primary);
    }

    .compare-subtitle {
      font-size: var(--font-sm);
      color: var(--text-muted);
      margin-top: 4px;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      color: var(--accent-primary);
      text-decoration: none;
      font-size: var(--font-sm);
    }

    .back-link:hover {
      text-decoration: underline;
    }

    /* Summary cards grid */
    .compare-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-md);
      margin-bottom: var(--space-xl);
    }

    .run-summary-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
    }

    .run-summary-card .run-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .remove-run {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: var(--font-sm);
    }

    .run-summary-card .remove-run:hover {
      background: var(--error-dim);
      color: var(--error);
    }

    .run-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .run-summary-card .run-name {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      color: var(--text-primary);
      word-break: break-all;
    }

    .run-summary-card .run-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .stats-row {
      display: flex;
      justify-content: space-between;
      padding: var(--space-xs) 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .run-summary-card .stats-row:last-child {
      border-bottom: none;
    }

    .run-summary-card .stat-label {
      color: var(--text-muted);
      font-size: var(--font-sm);
    }

    .run-summary-card .stat-val {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-primary);
    }

    .run-summary-card .stat-val.high { color: var(--success); }
    .run-summary-card .stat-val.mid { color: var(--warning); }
    .run-summary-card .stat-val.low { color: var(--error); }

    /* Comparison Stats Section */
    .comparison-stats {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
      margin-bottom: var(--space-xl);
    }

    .comparison-stats h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .stats-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .stats-row {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
    }

    .stat-box {
      background: var(--bg-elevated);
      border-radius: 6px;
      padding: var(--space-sm) var(--space-md);
      flex: 1;
      min-width: 120px;
    }

    .stat-box.wide {
      flex: 100%;
      padding: var(--space-md);
    }

    .stat-box .stat-title {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
    }

    .stat-box .stat-main {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
    }

    .stat-box.wide .stat-main {
      font-size: var(--font-lg);
    }

    .stat-box .stat-main.positive { color: var(--success); }
    .stat-box .stat-main.negative { color: var(--error); }
    .stat-box .stat-main.neutral { color: var(--text-secondary); }

    .stat-box .stat-detail {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* Win/Loss bars */
    .win-loss-bar {
      display: flex;
      height: 28px;
      border-radius: 4px;
      overflow: hidden;
      margin-top: var(--space-sm);
      gap: 2px;
    }

    .win-loss-bar .segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-xs);
      font-weight: 600;
      color: #fff;
      transition: flex 0.3s;
      min-width: 0;
      padding: 0 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .win-loss-bar .segment.tie {
      background: var(--text-muted);
    }

    .win-loss-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .win-loss-legend .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: var(--font-xs);
      color: var(--text-secondary);
    }

    .win-loss-legend .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .win-loss-legend .legend-count {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    /* Distribution bar */
    .distribution-bar {
      display: flex;
      height: 32px;
      border-radius: 4px;
      overflow: hidden;
      gap: 2px;
      margin-top: var(--space-sm);
    }

    .dist-segment {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 0;
      padding: 2px 4px;
      color: #fff;
      font-size: var(--font-xs);
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .dist-segment .dist-label {
      font-weight: 700;
      font-size: var(--font-sm);
    }

    .dist-segment .dist-count {
      font-size: 10px;
      opacity: 0.9;
    }

    .dist-segment.dist-zero {
      background: var(--error);
    }

    .dist-segment.dist-all {
      background: var(--success);
    }

    .dist-segment.dist-partial {
      background: var(--warning);
    }

    .distribution-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .dist-legend-item {
      display: inline-flex;
      gap: 4px;
    }

    .dist-legend-item strong {
      color: var(--text-secondary);
    }

    /* Metrics comparison table */
    .metrics-comparison {
      margin-bottom: var(--space-xl);
    }

    .metrics-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .metrics-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
    }

    .metrics-table th,
    .metrics-table td {
      padding: var(--space-sm) var(--space-md);
      text-align: left;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metrics-table th:not(:first-child),
    .metrics-table td:not(:first-child) {
      text-align: center;
    }

    .metrics-table thead th {
      background: var(--bg-elevated);
      font-size: var(--font-xs);
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metrics-table tbody td {
      font-size: var(--font-sm);
    }

    .metrics-table .metric-name {
      font-family: var(--font-mono);
      color: var(--text-secondary);
    }

    .metrics-table .metric-val {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    .metrics-table .metric-val.high { color: var(--success); }
    .metrics-table .metric-val.mid { color: var(--warning); }
    .metrics-table .metric-val.low { color: var(--error); }

    .metrics-table .metric-val.best {
      background: var(--success-dim);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .metrics-table .diff {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .metrics-table .diff.positive {
      color: var(--success);
    }

    .metrics-table .diff.negative {
      color: var(--error);
    }

    /* Side-by-side items view */
    .items-comparison {
      margin-bottom: var(--space-xl);
    }

    .items-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .items-filter {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .filter-count {
      font-size: var(--font-sm);
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .filter-count .count-num {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .items-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .item-comparison-row {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-md);
    }

    .item-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding-bottom: var(--space-sm);
      border-bottom: 1px solid var(--border-subtle);
    }

    .item-index {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-muted);
    }

    .item-input-row,
    .item-expected-row {
      background: var(--bg-elevated);
      padding: var(--space-sm);
      border-radius: 4px;
    }

    .item-input-row .input-label,
    .item-expected-row .expected-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .item-input-row .input-text,
    .item-expected-row .expected-text {
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .item-expected-row {
      background: var(--success-dim);
      border-left: 3px solid var(--success);
    }

    .item-expected-row .expected-label {
      color: var(--success);
    }

    .item-outputs-row {
      display: grid;
      grid-template-columns: repeat(var(--run-count, 2), 1fr);
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .item-run-output {
      border-left: 3px solid var(--border-default);
      padding-left: var(--space-sm);
      background: var(--bg-elevated);
      border-radius: 0 4px 4px 0;
      padding: var(--space-sm);
    }

    .item-run-output .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
      flex-wrap: wrap;
      gap: 4px;
    }

    .item-run-output .run-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .item-run-output .output-badges {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .item-run-output .metric-badge,
    .item-run-output .latency-badge {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-surface);
    }

    .item-run-output .metric-badge.high { background: var(--success-dim); color: var(--success); }
    .item-run-output .metric-badge.mid { background: var(--warning-dim); color: var(--warning); }
    .item-run-output .metric-badge.low { background: var(--error-dim); color: var(--error); }

    .item-run-output .latency-badge {
      color: var(--text-muted);
    }

    .item-run-output .output-text {
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 150px;
      overflow-y: auto;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: var(--space-sm);
      margin-top: var(--space-lg);
    }

    .pagination button {
      padding: var(--space-xs) var(--space-md);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .pagination button:hover:not(:disabled) {
      background: var(--bg-hover);
    }

    .pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination .page-info {
      display: flex;
      align-items: center;
      font-size: var(--font-sm);
      color: var(--text-muted);
    }

    /* Empty/loading states */
    .compare-loading,
    .compare-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 300px;
      color: var(--text-muted);
    }

    .compare-loading .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border-default);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: var(--space-md);
    }

    /* Formatted object/dict display styles */
    .formatted-object,
    .formatted-array {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      line-height: 1.6;
    }

    .formatted-row {
      padding: 6px 0;
      padding-left: var(--space-md);
      border-left: 2px solid var(--border-subtle);
      margin-left: 2px;
      margin-bottom: 4px;
    }

    .formatted-row:hover {
      background: var(--bg-hover);
      border-left-color: var(--accent-primary);
    }

    .formatted-key {
      color: #f472b6;
      font-weight: 600;
      display: block;
      margin-bottom: 4px;
      text-transform: uppercase;
      font-size: var(--font-xs);
      letter-spacing: 0.5px;
    }

    .formatted-string {
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      display: block;
      line-height: 1.5;
    }

    .formatted-number {
      color: #fbbf24;
      font-weight: 600;
    }

    .formatted-boolean {
      color: #a855f7;
      font-weight: 600;
    }

    .formatted-null {
      color: var(--text-muted);
      font-style: italic;
    }

    .formatted-array-item {
      padding: 6px 0;
      padding-left: var(--space-md);
      border-left: 2px solid var(--border-subtle);
      margin-left: 2px;
      margin-bottom: 4px;
    }

    .formatted-array-item:hover {
      background: var(--bg-hover);
      border-left-color: var(--accent-primary);
    }

    .formatted-index {
      color: #60a5fa;
      font-size: var(--font-xs);
      margin-right: 4px;
      font-weight: 600;
    }

    /* Shared toggle button for metric details */
    .item-metric-details-toggle {
      margin-top: var(--space-md);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
    }

    .metric-details-toggle {
      font-size: var(--font-xs);
      color: var(--accent-primary);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 4px;
      background: var(--bg-surface);
      border: 1px solid var(--border-subtle);
    }

    .metric-details-toggle:hover {
      background: var(--bg-hover);
      border-color: var(--accent-primary);
    }

    /* Per-run metric details (inside each run output) */
    .run-metric-details {
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
      display: none;
    }

    .run-metric-details.expanded {
      display: block;
    }

    .metric-detail-row {
      padding: var(--space-sm) 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metric-detail-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .metric-detail-name {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
      display: block;
    }

    .metric-detail-value {
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Metric tabs */
    .metric-tabs {
      display: flex;
      gap: 2px;
      margin-bottom: var(--space-md);
      background: var(--bg-elevated);
      padding: 3px;
      border-radius: 6px;
      width: fit-content;
    }

    .metric-tab {
      padding: 6px 16px;
      font-size: var(--font-sm);
      font-family: var(--font-mono);
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .metric-tab:hover {
      color: var(--text-secondary);
      background: var(--bg-hover);
    }

    .metric-tab.active {
      color: var(--text-primary);
      background: var(--bg-surface);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Metric selector for items */
    .items-filter-row {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
      flex-wrap: wrap;
    }

    .filter-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Winner indicator in item rows */
    .metric-winner {
      background: var(--success-dim);
      border-radius: 3px;
      padding: 0 4px;
      margin-left: 4px;
      font-size: var(--font-xs);
      color: var(--success);
    }

    .metric-score-row {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: 4px 0;
    }

    .metric-score-row.highlighted {
      background: var(--bg-hover);
      margin: 0 -4px;
      padding: 4px;
      border-radius: 3px;
    }

    .metric-score-name {
      font-size: var(--font-sm);
      color: var(--text-muted);
      min-width: 100px;
    }

    .metric-score-value {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      font-weight: 600;
    }

    .metric-scores-inline {
      margin-top: var(--space-sm);
      padding-top: var(--space-sm);
      border-top: 1px solid var(--border-subtle);
    }
  </style>
</head>
<body>
  <!-- Minimal header -->
  <header class="stats-bar">
    <div class="logo">
      <span class="logo-icon">◈</span>
      <span class="logo-text">LLM-EVAL</span>
    </div>
    <div class="stat-cells">
      <div class="stat-cell">
        <span class="stat-label">COMPARING</span>
        <span class="stat-value" id="run-count">—</span>
      </div>
      <div class="stat-cell">
        <span class="stat-label">TOTAL ITEMS</span>
        <span class="stat-value" id="total-items">—</span>
      </div>
      <div class="stat-cell">
        <span class="stat-label">METRICS</span>
        <span class="stat-value" id="metric-count">—</span>
      </div>
    </div>
  </header>

  <main class="compare-container">
    <div class="compare-loading" id="loading">
      <div class="spinner"></div>
      <span>Loading comparison data...</span>
    </div>

    <div class="compare-empty" id="empty" style="display: none;">
      <div style="font-size: 48px; margin-bottom: var(--space-md);">∅</div>
      <h2>No runs to compare</h2>
      <p>Select at least 2 runs from the dashboard to compare.</p>
      <a href="/" class="back-link">← Back to Dashboard</a>
    </div>

    <div id="compare-content" style="display: none;">
      <div class="compare-header-bar">
        <div>
          <div class="compare-title">Run Comparison</div>
          <div class="compare-subtitle" id="compare-subtitle">Comparing evaluation runs</div>
        </div>
        <a href="/" class="back-link">← Back to Dashboard</a>
      </div>

      <!-- Run summaries -->
      <div class="compare-summary" id="run-summaries"></div>

      <!-- Metrics comparison -->
      <div class="metrics-comparison">
        <h3>Metric Averages</h3>
        <table class="metrics-table" id="metrics-table">
          <thead id="metrics-thead"></thead>
          <tbody id="metrics-tbody"></tbody>
        </table>
      </div>

      <!-- Comparison Statistics -->
      <div class="comparison-stats" id="comparison-stats">
        <h3>Comparison Overview</h3>
        <div class="metric-tabs" id="overview-metric-tabs"></div>
        <div class="stats-grid" id="stats-grid"></div>
      </div>

      <!-- Side-by-side items -->
      <div class="items-comparison">
        <h3>Item-by-Item Comparison</h3>
        <div class="items-filter-row">
          <span class="filter-label">Metric:</span>
          <select id="items-metric-select" class="filter-select"></select>
          <span class="filter-label">Filter:</span>
          <select id="item-filter" class="filter-select">
            <option value="all">All Items</option>
            <option value="different">Different Outputs</option>
            <option value="errors">With Errors</option>
            <option value="all_correct">All Runs 100%</option>
            <option value="all_wrong">No Run 100%</option>
            <option value="rarely_solved">Rarely Solved (≤25%)</option>
            <option value="unique_solve">Uniquely Solved (1 run only)</option>
          </select>
          <span class="filter-label">Winner:</span>
          <select id="run-winner-filter" class="filter-select">
            <option value="any">Any Winner</option>
          </select>
          <span class="filter-count" id="filter-count"></span>
        </div>
        <div class="items-grid" id="items-grid"></div>
        <div class="pagination" id="pagination"></div>
      </div>
    </div>
  </main>

  <script>
    (() => {
      'use strict';

      const COLORS = [
        '#00d4aa', '#00a8ff', '#a855f7', '#f472b6',
        '#fbbf24', '#60a5fa', '#34d399', '#fb923c'
      ];

      const state = {
        runs: [],
        allMetrics: [],
        selectedOverviewMetric: null,  // For Comparison Overview tabs
        selectedItemsMetric: null,     // For Item-by-Item filters
        itemFilter: 'all',
        winnerFilter: 'any',
        page: 1,
        pageSize: 20,
        comparisonStats: {},  // Now keyed by metric name
      };

      const el = (id) => document.getElementById(id);

      function getSuccessClass(rate) {
        if (rate >= 0.9) return 'high';
        if (rate >= 0.7) return 'mid';
        return 'low';
      }

      function formatPercent(val) {
        if (val === null || val === undefined) return '—';
        return (val * 100).toFixed(1) + '%';
      }

      function formatLatency(ms) {
        if (!ms || ms < 1) return '—';
        if (ms < 1000) return `${Math.round(ms)}ms`;
        return `${(ms / 1000).toFixed(1)}s`;
      }

      function buildDistributionBar(stats) {
        return stats.correctDistribution.map((count, idx) => {
          if (count === 0) return '';
          const pct = (count / stats.totalCompared * 100).toFixed(0);
          const isZero = idx === 0;
          const isAll = idx === state.runs.length;
          const colorClass = isZero ? 'dist-zero' : isAll ? 'dist-all' : 'dist-partial';
          return `<div class="dist-segment ${colorClass}" style="flex: ${count}" title="${idx}/${state.runs.length} correct: ${count} items (${pct}%)">
            <span class="dist-label">${idx}</span>
            <span class="dist-count">${count}</span>
          </div>`;
        }).join('');
      }

      async function loadComparisonData() {
        // Get selected files from sessionStorage
        const filesJson = sessionStorage.getItem('compareRuns');
        if (!filesJson) {
          showEmpty();
          return;
        }

        let files;
        try {
          files = JSON.parse(filesJson);
        } catch {
          showEmpty();
          return;
        }

        if (!Array.isArray(files) || files.length < 2) {
          showEmpty();
          return;
        }

        // Fetch comparison data from API
        const params = files.map(f => 'files=' + encodeURIComponent(f)).join('&');
        try {
          const response = await fetch('/api/compare?' + params);
          const data = await response.json();

          if (!data.runs || data.runs.length < 2) {
            showEmpty();
            return;
          }

          state.runs = data.runs;
          processRuns();
          render();
        } catch (err) {
          console.error('Failed to load comparison:', err);
          showEmpty();
        }
      }

      function processRuns() {
        // Collect all unique metrics
        const metricsSet = new Set();
        for (const run of state.runs) {
          const snap = run.snapshot || {};
          const names = snap.metric_names || run.run?.metric_names || [];
          names.forEach(m => metricsSet.add(m));
        }
        state.allMetrics = Array.from(metricsSet).sort();

        // Set default selected metrics
        if (state.allMetrics.length > 0) {
          state.selectedOverviewMetric = state.allMetrics[0];
          state.selectedItemsMetric = state.allMetrics[0];
        }

        // Update header stats
        el('run-count').textContent = state.runs.length;
        el('metric-count').textContent = state.allMetrics.length;

        // Calculate total items (use max across runs)
        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));
        el('total-items').textContent = maxItems;

        // Calculate comparison statistics for each metric
        state.comparisonStats = {};
        for (const metric of state.allMetrics) {
          state.comparisonStats[metric] = calculateComparisonStatsForMetric(metric);
        }

        // Populate metric selectors
        populateMetricSelectors();

        // Populate winner filter dropdown
        populateWinnerFilter();
      }

      function populateMetricSelectors() {
        // Overview metric tabs
        const tabsContainer = el('overview-metric-tabs');
        if (tabsContainer) {
          tabsContainer.innerHTML = state.allMetrics.map(metric =>
            `<button class="metric-tab ${metric === state.selectedOverviewMetric ? 'active' : ''}" data-metric="${metric}">${metric}</button>`
          ).join('');

          tabsContainer.querySelectorAll('.metric-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              state.selectedOverviewMetric = tab.dataset.metric;
              tabsContainer.querySelectorAll('.metric-tab').forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              renderComparisonStats();
            });
          });
        }

        // Items metric selector dropdown
        const itemsMetricSelect = el('items-metric-select');
        if (itemsMetricSelect) {
          itemsMetricSelect.innerHTML = state.allMetrics.map(metric =>
            `<option value="${metric}" ${metric === state.selectedItemsMetric ? 'selected' : ''}>${metric}</option>`
          ).join('');

          itemsMetricSelect.addEventListener('change', (e) => {
            state.selectedItemsMetric = e.target.value;
            state.page = 1;
            populateWinnerFilter();
            renderItems();
          });
        }
      }

      function calculateComparisonStatsForMetric(metricName) {
        const stats = {
          wins: new Array(state.runs.length).fill(0),
          ties: 0,
          totalCompared: 0,
          avgScores: [],
          avgLatencies: [],
          scoreDelta: 0,
          latencyDelta: 0,
          agreementRate: 0,
          allCorrect: 0,
          allWrong: 0,
          passAtK: 0, // Items where at least one run scored 100%
          passHatK: 0, // Items where ALL runs scored 100%
          stabilityCount: 0, // Items where all runs were either all correct or all wrong (no mix)
          maxAtK: 0, // Sum of max scores across all items (best possible if you pick best run per item)
          correctDistribution: [], // How many items had 0, 1, 2, ... N runs correct
          overallAvgScore: 0,
          overallAvgLatency: 0,
          errorCounts: [],
          errorTypes: [],
          biggestWins: [],
          itemWinners: [], // For each item, which run won
        };

        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));

        // Initialize correct distribution array (index = number of runs correct, value = count)
        stats.correctDistribution = new Array(state.runs.length + 1).fill(0);

        // Helper to get metric index for a run
        function getMetricIndex(run) {
          const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
          return metricNames.indexOf(metricName);
        }

        // Calculate per-run stats
        for (let runIdx = 0; runIdx < state.runs.length; runIdx++) {
          const run = state.runs[runIdx];
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricIdx = getMetricIndex(run);

          let scoreSum = 0, scoreCount = 0, latSum = 0, latCount = 0;
          let timeoutErrors = 0, runtimeErrors = 0, otherErrors = 0;

          for (const row of rows) {
            // Score for the selected metric
            if (metricIdx >= 0) {
              const v = (row.metric_values || [])[metricIdx];
              const n = parseFloat(v);
              if (!isNaN(n)) { scoreSum += n; scoreCount++; }
            }
            // Latency
            if (row.latency_ms && row.status === 'completed') {
              latSum += row.latency_ms;
              latCount++;
            }
            // Errors
            if (row.status === 'error') {
              const output = (row.output_full || row.output || '').toLowerCase();
              if (output.includes('timeout')) timeoutErrors++;
              else if (output.includes('error')) runtimeErrors++;
              else otherErrors++;
            }
          }

          stats.avgScores.push(scoreCount > 0 ? scoreSum / scoreCount : 0);
          stats.avgLatencies.push(latCount > 0 ? latSum / latCount : 0);
          stats.errorCounts.push(timeoutErrors + runtimeErrors + otherErrors);
          stats.errorTypes.push({ timeout: timeoutErrors, runtime: runtimeErrors, other: otherErrors });
        }

        // Compare items head-to-head
        let agreements = 0;
        for (let i = 0; i < maxItems; i++) {
          const scores = state.runs.map((run) => {
            const snap = run.snapshot || {};
            const rows = snap.rows || [];
            const row = rows.find(r => r.index === i);
            if (!row) return null;
            const metricIdx = getMetricIndex(run);
            if (metricIdx < 0) return null;
            const v = (row.metric_values || [])[metricIdx];
            const n = parseFloat(v);
            return isNaN(n) ? null : n;
          });

          const validScores = scores.filter(s => s !== null);

          // Max@K: track the best score for this item across all runs
          if (validScores.length > 0) {
            stats.maxAtK += Math.max(...validScores);
          }

          // Count distribution for ALL items (even those with missing data)
          const numCorrect = scores.filter(s => s !== null && s >= 0.9999).length;
          stats.correctDistribution[numCorrect]++;

          // For head-to-head comparison, need at least 2 valid scores
          if (validScores.length < 2) {
            stats.itemWinners.push(null);
            // Still count pass@k for items with any data
            if (numCorrect > 0) stats.passAtK++;
            if (scores.every(s => s === null || s < 0.0001)) stats.allWrong++;
            if (numCorrect === scores.filter(s => s !== null).length && numCorrect > 0) stats.allCorrect++;
            stats.totalCompared++;
            continue;
          }

          stats.totalCompared++;

          const maxScore = Math.max(...validScores);
          const minScore = Math.min(...validScores);
          const winners = scores.map((s, idx) => s === maxScore ? idx : -1).filter(x => x >= 0);

          // Check if ALL scores are the same (true tie)
          if (maxScore === minScore) {
            stats.ties++;
            stats.itemWinners.push('tie');
          } else if (winners.length === 1) {
            // Clear winner - only one run has the HIGHEST score (beat all others)
            stats.wins[winners[0]]++;
            stats.itemWinners.push(winners[0]);
            // Track biggest wins
            const diff = maxScore - minScore;
            stats.biggestWins.push({ index: i, winner: winners[0], diff, scores });
          } else {
            // Multiple runs tied for the highest score, but didn't beat everyone
            // This counts as a tie (no clear winner)
            stats.ties++;
            stats.itemWinners.push('tie');
          }

          // All correct / all wrong / pass@k (at least one run got 100%)
          // Note: numCorrect was already calculated above
          const allCorrectItem = numCorrect === state.runs.length;
          const allWrongItem = validScores.every(s => s < 0.0001);

          if (allCorrectItem) stats.allCorrect++;
          if (allWrongItem) stats.allWrong++;
          if (numCorrect > 0) stats.passAtK++;

          // Pass^K: ALL runs got 100%
          if (allCorrectItem) stats.passHatK++;

          // Stability: all correct OR all wrong (no mixed results)
          if (allCorrectItem || allWrongItem) stats.stabilityCount++;

          // Agreement (runs scored similarly - within 10% of each other)
          const scoreRange = maxScore - minScore;
          if (scoreRange < 0.1) agreements++;
        }

        stats.agreementRate = stats.totalCompared > 0 ? agreements / stats.totalCompared : 0;

        // Calculate overall averages across all runs
        const validScoresAll = stats.avgScores.filter(s => s > 0);
        const validLatenciesAll = stats.avgLatencies.filter(l => l > 0);
        stats.overallAvgScore = validScoresAll.length > 0
          ? validScoresAll.reduce((a, b) => a + b, 0) / validScoresAll.length
          : 0;
        stats.overallAvgLatency = validLatenciesAll.length > 0
          ? validLatenciesAll.reduce((a, b) => a + b, 0) / validLatenciesAll.length
          : 0;

        // Score and latency deltas (comparing first two runs)
        if (state.runs.length >= 2) {
          stats.scoreDelta = stats.avgScores[0] - stats.avgScores[1];
          stats.latencyDelta = stats.avgLatencies[0] - stats.avgLatencies[1];
        }

        // Sort biggest wins
        stats.biggestWins.sort((a, b) => b.diff - a.diff);
        stats.biggestWins = stats.biggestWins.slice(0, 5);

        return stats;
      }

      function populateWinnerFilter() {
        const select = el('run-winner-filter');
        if (!select) return;

        let options = '<option value="any">Any Winner</option>';
        options += '<option value="tie">Ties Only</option>';

        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="win_${idx}">${name} Won</option>`;
        });

        // Add "Only X Solved" options for unique insights
        options += '<optgroup label="Uniquely Solved By">';
        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="only_${idx}">Only ${name}</option>`;
        });
        options += '</optgroup>';

        select.innerHTML = options;
      }

      function removeRun(idx) {
        if (state.runs.length <= 2) return;

        // Remove from state
        state.runs.splice(idx, 1);

        // Update sessionStorage so it persists
        const filesJson = sessionStorage.getItem('compareRuns');
        if (filesJson) {
          try {
            const files = JSON.parse(filesJson);
            files.splice(idx, 1);
            sessionStorage.setItem('compareRuns', JSON.stringify(files));
          } catch {}
        }

        // Reset filters that might reference removed run
        state.winnerFilter = 'any';
        state.page = 1;

        // Reprocess and re-render
        processRuns();
        render();
      }

      function showEmpty() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'flex';
        el('compare-content').style.display = 'none';
      }

      function render() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'none';
        el('compare-content').style.display = 'block';

        renderSummaries();
        renderComparisonStats();
        renderMetricsTable();
        renderItems();
      }

      function renderComparisonStats() {
        const container = el('stats-grid');
        if (!container || !state.comparisonStats || !state.selectedOverviewMetric) return;

        const stats = state.comparisonStats[state.selectedOverviewMetric];
        if (!stats) return;
        const runNames = state.runs.map((r, i) => r.run?.run_name || `Run ${i + 1}`);

        // Build win/loss bar with proper colors
        const total = stats.totalCompared || 1;
        const winBarSegments = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          const count = stats.wins[idx];
          if (count === 0) return '';
          return `<div class="segment" style="flex: ${count}; background: ${color}">${count}</div>`;
        }).join('');
        const tieSegment = stats.ties > 0
          ? `<div class="segment tie" style="flex: ${stats.ties}">${stats.ties}</div>`
          : '';

        // Build legend
        const legendItems = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          return `<div class="legend-item">
            <div class="legend-dot" style="background: ${color}"></div>
            <span>${runNames[idx]}:</span>
            <span class="legend-count">${stats.wins[idx]}</span>
          </div>`;
        }).join('');
        const tieLegend = `<div class="legend-item">
          <div class="legend-dot" style="background: var(--text-muted)"></div>
          <span>Ties:</span>
          <span class="legend-count">${stats.ties}</span>
        </div>`;

        container.innerHTML = `
          <div class="stats-row">
            <div class="stat-box">
              <div class="stat-title">Pass@${state.runs.length}</div>
              <div class="stat-main positive">${formatPercent(stats.passAtK / stats.totalCompared)}</div>
              <div class="stat-detail">≥1 run correct</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Pass^${state.runs.length}</div>
              <div class="stat-main positive">${formatPercent(stats.passHatK / stats.totalCompared)}</div>
              <div class="stat-detail">all runs correct</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Max@${state.runs.length}</div>
              <div class="stat-main positive">${formatPercent(stats.maxAtK / stats.totalCompared)}</div>
              <div class="stat-detail">best per item</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Stability</div>
              <div class="stat-main">${formatPercent(stats.stabilityCount / stats.totalCompared)}</div>
              <div class="stat-detail">all same result</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Score</div>
              <div class="stat-main">${formatPercent(stats.overallAvgScore)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Latency</div>
              <div class="stat-main">${formatLatency(stats.overallAvgLatency)}</div>
            </div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Winner Breakdown</div>
            <div class="win-loss-bar">
              ${winBarSegments}
              ${tieSegment}
            </div>
            <div class="win-loss-legend">
              ${legendItems}
              ${tieLegend}
            </div>
            <div class="stat-detail">${stats.totalCompared} items compared</div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Correct Distribution (how many runs got each item right)</div>
            <div class="distribution-bar">
              ${buildDistributionBar(stats)}
            </div>
          </div>
        `;
      }

      function renderSummaries() {
        const container = el('run-summaries');
        container.innerHTML = state.runs.map((run, idx) => {
          const info = run.run || {};
          const snap = run.snapshot || {};
          const stats = snap.stats || {};
          const color = COLORS[idx % COLORS.length];
          const successRate = (stats.completed || 0) / (stats.total || 1);
          const successClass = getSuccessClass(successRate);

          const canRemove = state.runs.length > 2;
          return `
            <div class="run-summary-card">
              <div class="run-header">
                <div class="run-color-dot" style="background: ${color}"></div>
                <div class="run-name">${info.run_name || 'Run ' + (idx + 1)}</div>
                ${canRemove ? `<button class="remove-run" data-idx="${idx}" title="Remove from comparison">✕</button>` : ''}
              </div>
              <div class="run-meta">
                <span class="tag task">${info.dataset_name || '—'}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Total Items</span>
                <span class="stat-val">${stats.total || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Completed</span>
                <span class="stat-val">${stats.completed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Failed</span>
                <span class="stat-val ${stats.failed > 0 ? 'low' : ''}">${stats.failed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Success Rate</span>
                <span class="stat-val ${successClass}">${formatPercent(successRate)}</span>
              </div>
            </div>
          `;
        }).join('');

        // Add click handlers for remove buttons
        container.querySelectorAll('.remove-run').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const idx = parseInt(e.target.dataset.idx, 10);
            removeRun(idx);
          });
        });
      }

      function renderMetricsTable() {
        const thead = el('metrics-thead');
        const tbody = el('metrics-tbody');

        // Header row
        thead.innerHTML = `
          <tr>
            <th>Metric</th>
            ${state.runs.map((run, idx) => {
              const info = run.run || {};
              const color = COLORS[idx % COLORS.length];
              return `<th><span style="display:inline-block;width:10px;height:10px;background:${color};border-radius:2px;margin-right:6px;"></span>${info.run_name || 'Run ' + (idx + 1)}</th>`;
            }).join('')}
          </tr>
        `;

        // Calculate metric averages and latency for each run
        const runMetricAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricNames = snap.metric_names || run.run?.metric_names || [];
          const avgs = {};

          for (const metric of state.allMetrics) {
            const idx = metricNames.indexOf(metric);
            if (idx === -1) {
              avgs[metric] = null;
              continue;
            }

            let sum = 0, count = 0;
            for (const row of rows) {
              const vals = row.metric_values || [];
              const v = vals[idx];
              const n = parseFloat(v);
              if (!isNaN(n)) {
                sum += n;
                count++;
              }
            }
            avgs[metric] = count > 0 ? sum / count : null;
          }
          return avgs;
        });

        // Calculate average latency for each run
        const runLatencyAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          let sum = 0, count = 0;
          for (const row of rows) {
            if (row.latency_ms && row.status === 'completed') {
              sum += row.latency_ms;
              count++;
            }
          }
          return count > 0 ? sum / count : null;
        });

        // Find best (lowest) latency
        const bestLatency = Math.min(...runLatencyAvgs.filter(v => v !== null));

        // Find best value for each metric
        const bestValues = {};
        for (const metric of state.allMetrics) {
          let best = -Infinity;
          for (const avgs of runMetricAvgs) {
            if (avgs[metric] !== null && avgs[metric] > best) {
              best = avgs[metric];
            }
          }
          bestValues[metric] = best > -Infinity ? best : null;
        }

        // Render rows - metrics first, then latency
        const metricRows = state.allMetrics.map(metric => {
          const cells = runMetricAvgs.map(avgs => {
            const val = avgs[metric];
            if (val === null) return '<td class="metric-val">—</td>';
            const isBest = val === bestValues[metric] && state.runs.length > 1;
            const cls = getSuccessClass(val);
            return `<td class="metric-val ${cls} ${isBest ? 'best' : ''}">${formatPercent(val)}</td>`;
          }).join('');

          return `
            <tr>
              <td class="metric-name">${metric}</td>
              ${cells}
            </tr>
          `;
        }).join('');

        // Latency row
        const latencyCells = runLatencyAvgs.map(val => {
          if (val === null) return '<td class="metric-val">—</td>';
          const isBest = val === bestLatency && state.runs.length > 1;
          return `<td class="metric-val ${isBest ? 'best' : ''}" style="${isBest ? 'background: var(--success-dim);' : ''}">${formatLatency(val)}</td>`;
        }).join('');

        const latencyRow = `
          <tr>
            <td class="metric-name">Avg Latency</td>
            ${latencyCells}
          </tr>
        `;

        tbody.innerHTML = metricRows + latencyRow;
      }

      function getFilteredItems() {
        // Build aligned item list across runs
        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));
        const items = [];
        const selectedMetric = state.selectedItemsMetric;
        const stats = selectedMetric ? state.comparisonStats[selectedMetric] : null;

        // Helper to get metric index for a run
        function getMetricIndex(run) {
          const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
          return selectedMetric ? metricNames.indexOf(selectedMetric) : 0;
        }

        for (let i = 0; i < maxItems; i++) {
          const rowData = state.runs.map(run => {
            const rows = run.snapshot?.rows || [];
            return rows.find(r => r.index === i) || null;
          });

          // Get scores for this item based on selected metric
          const scores = rowData.map((row, runIdx) => {
            if (!row) return null;
            const run = state.runs[runIdx];
            const metricIdx = getMetricIndex(run);
            if (metricIdx < 0) return null;
            const v = (row.metric_values || [])[metricIdx];
            const n = parseFloat(v);
            return isNaN(n) ? null : n;
          });
          const validScores = scores.filter(s => s !== null);

          // Apply item filter
          if (state.itemFilter === 'different') {
            const outputs = rowData.map(r => r?.output_full || r?.output || '').filter(o => o);
            const uniqueOutputs = new Set(outputs);
            if (uniqueOutputs.size <= 1) continue;
          } else if (state.itemFilter === 'errors') {
            const hasError = rowData.some(r => r?.status === 'error');
            if (!hasError) continue;
          } else if (state.itemFilter === 'all_correct') {
            // All runs got 100% (matches distribution "all correct")
            if (validScores.length < 2 || !validScores.every(s => s >= 0.9999)) continue;
          } else if (state.itemFilter === 'all_wrong') {
            // No run got 100% (matches distribution "0 correct")
            if (validScores.length < 2 || validScores.some(s => s >= 0.9999)) continue;
          } else if (state.itemFilter === 'rarely_solved') {
            // 25% or fewer runs got 100%
            const numCorrect = scores.filter(s => s !== null && s >= 0.9999).length;
            const threshold = Math.max(1, Math.floor(state.runs.length * 0.25));
            if (numCorrect === 0 || numCorrect > threshold) continue;
          } else if (state.itemFilter === 'unique_solve') {
            // Exactly 1 run got 100%
            const numCorrect = scores.filter(s => s !== null && s >= 0.9999).length;
            if (numCorrect !== 1) continue;
          }

          // Apply winner filter
          if (state.winnerFilter !== 'any' && stats) {
            const winner = stats.itemWinners[i];
            if (state.winnerFilter === 'tie') {
              // Only show ties (all runs same score OR multiple tied for highest)
              if (winner !== 'tie') continue;
            } else if (state.winnerFilter.startsWith('win_')) {
              const winnerIdx = parseInt(state.winnerFilter.replace('win_', ''), 10);
              // Only show items where this run was the SOLE winner (beat all others)
              if (winner !== winnerIdx) continue;
            } else if (state.winnerFilter.startsWith('only_')) {
              // Only show items where ONLY this run got 100%
              const runIdx = parseInt(state.winnerFilter.replace('only_', ''), 10);
              const correctRuns = scores.map((s, idx) => s !== null && s >= 0.9999 ? idx : -1).filter(x => x >= 0);
              if (correctRuns.length !== 1 || correctRuns[0] !== runIdx) continue;
            }
          }

          items.push({ index: i, rowData });
        }

        return items;
      }

      function renderItems(scrollToTop = false) {
        const container = el('items-grid');
        const paginationEl = el('pagination');
        const filterCountEl = el('filter-count');
        const items = getFilteredItems();

        // Update filter count display
        filterCountEl.innerHTML = `<span class="count-num">${items.length}</span> items`;

        // Set CSS variable for grid columns
        container.style.setProperty('--run-count', state.runs.length);

        // Pagination
        const totalPages = Math.max(1, Math.ceil(items.length / state.pageSize));
        if (state.page > totalPages) state.page = totalPages;
        const start = (state.page - 1) * state.pageSize;
        const pageItems = items.slice(start, start + state.pageSize);

        if (items.length === 0) {
          container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);">No items match the current filter</div>';
          paginationEl.innerHTML = '';
          return;
        }

        container.innerHTML = pageItems.map(({ index, rowData }) => {
          // Get input and expected from any available row
          const inputRow = rowData.find(r => r);
          const input = inputRow?.input_full || inputRow?.input || '—';
          const expected = inputRow?.expected_full || inputRow?.expected || '';

          const outputCells = rowData.map((row, runIdx) => {
            const color = COLORS[runIdx % COLORS.length];
            const runInfo = state.runs[runIdx]?.run || {};

            if (!row) {
              return `
                <div class="item-run-output" style="border-left-color: ${color}">
                  <div class="output-header">
                    <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)}</span>
                  </div>
                  <div class="output-text" style="color:var(--text-muted);font-style:italic;">No data</div>
                </div>
              `;
            }

            const output = row.output_full || row.output || '—';
            const status = row.status || 'pending';
            const latencyMs = row.latency_ms;

            // Get metric values and metadata
            const metricVals = row.metric_values || [];
            const metricMeta = row.metric_meta || {};
            const run = state.runs[runIdx];
            const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];

            // Determine if this run is the winner for the selected metric
            const selectedMetric = state.selectedItemsMetric;
            const stats = selectedMetric ? state.comparisonStats[selectedMetric] : null;
            const itemWinner = stats?.itemWinners?.[index];
            const isWinner = itemWinner === runIdx;

            // Build inline metric scores (all metrics shown, selected one highlighted)
            const metricScoresHtml = metricNames.map((name, i) => {
              const score = metricVals[i];
              const v = parseFloat(score);
              if (isNaN(v)) return '';

              const cls = getSuccessClass(v);
              const isSelected = name === selectedMetric;
              const winnerBadge = isSelected && isWinner ? '<span class="metric-winner">★</span>' : '';

              return `<div class="metric-score-row ${isSelected ? 'highlighted' : ''}">
                <span class="metric-score-name">${escapeHtml(name)}</span>
                <span class="metric-score-value ${cls}">${formatPercent(v)}</span>
                ${winnerBadge}
              </div>`;
            }).join('');

            // Latency badge
            const latencyBadge = latencyMs ? `<span class="latency-badge">${formatLatency(latencyMs)}</span>` : '';

            // Build metric details for this run (hidden by default, controlled by shared toggle)
            let metricDetailsHtml = '';
            const hasMetricMeta = Object.keys(metricMeta).length > 0;

            if (hasMetricMeta) {
              const detailRows = metricNames.map((name) => {
                const meta = metricMeta[name] || {};
                const metaKeys = Object.keys(meta);
                if (metaKeys.length === 0) return '';

                return metaKeys.map(key => {
                  const val = meta[key];
                  if (val === undefined || val === null || val === '') return '';
                  const displayName = formatFieldName(key);
                  return `<div class="metric-detail-row">
                    <span class="metric-detail-name">${escapeHtml(name)} · ${displayName}</span>
                    <span class="metric-detail-value">${escapeHtml(String(val))}</span>
                  </div>`;
                }).join('');
              }).join('');

              if (detailRows) {
                metricDetailsHtml = `
                  <div class="run-metric-details" data-item="${index}">
                    ${detailRows}
                  </div>
                `;
              }
            }

            return `
              <div class="item-run-output" style="border-left-color: ${color}">
                <div class="output-header">
                  <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)}</span>
                  <span class="output-badges">${latencyBadge}</span>
                </div>
                <div class="output-text ${status === 'error' ? 'low' : ''}">${escapeHtml(output)}</div>
                <div class="metric-scores-inline">${metricScoresHtml}</div>
                ${metricDetailsHtml}
              </div>
            `;
          }).join('');

          // Only show expected row if there's expected output
          const expectedRow = expected ? `
              <div class="item-expected-row">
                <div class="expected-label">Expected Output</div>
                <div class="expected-text">${escapeHtml(expected)}</div>
              </div>
          ` : '';

          // Build shared metric details section (all runs' metadata in one expandable area)
          const metricDetailsHtml = buildMetricDetailsSection(index, rowData);

          return `
            <div class="item-comparison-row">
              <div class="item-header">
                <span class="item-index">#${index + 1}</span>
              </div>
              <div class="item-input-row">
                <div class="input-label">Input</div>
                <div class="input-text">${formatValue(input)}</div>
              </div>
              ${expectedRow}
              <div class="item-outputs-row" style="--run-count: ${state.runs.length}">
                ${outputCells}
              </div>
              ${metricDetailsHtml}
            </div>
          `;
        }).join('');

        // Pagination controls
        paginationEl.innerHTML = `
          <button id="prev-page" ${state.page <= 1 ? 'disabled' : ''}>← Prev</button>
          <span class="page-info">Page ${state.page} of ${totalPages}</span>
          <button id="next-page" ${state.page >= totalPages ? 'disabled' : ''}>Next →</button>
        `;

        el('prev-page').onclick = () => { state.page--; renderItems(true); };
        el('next-page').onclick = () => { state.page++; renderItems(true); };

        // Scroll to top of items grid if requested
        if (scrollToTop) {
          container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
      }

      // Global function for toggling all metric details for an item
      window.toggleItemMetricDetails = function(itemIndex) {
        const details = document.querySelectorAll(`.run-metric-details[data-item="${itemIndex}"]`);
        const icon = document.getElementById(`toggle-icon-${itemIndex}`);

        if (details.length === 0) return;

        const isExpanded = details[0].classList.contains('expanded');

        details.forEach(detail => {
          if (isExpanded) {
            detail.classList.remove('expanded');
          } else {
            detail.classList.add('expanded');
          }
        });

        if (icon) {
          icon.textContent = isExpanded ? '▶' : '▼';
        }
      };

      // Format field names to be more readable
      function formatFieldName(name) {
        // Remove common prefixes and convert to title case
        return name
          .replace(/_/g, ' ')
          .replace(/\b\w/g, c => c.toUpperCase());
      }

      // Build shared toggle button for metric details (controls all runs' details for this item)
      function buildMetricDetailsSection(itemIndex, rowData) {
        // Check if any run has metadata
        const hasAnyMeta = rowData.some(row => {
          if (!row) return false;
          const metricMeta = row.metric_meta || {};
          return Object.keys(metricMeta).some(metric => {
            const meta = metricMeta[metric] || {};
            return Object.keys(meta).length > 0;
          });
        });

        if (!hasAnyMeta) return '';

        return `
          <div class="item-metric-details-toggle">
            <button class="metric-details-toggle" onclick="toggleItemMetricDetails(${itemIndex})">
              <span class="toggle-icon" id="toggle-icon-${itemIndex}">▶</span> Metric Details
            </button>
          </div>
        `;
      }

      function formatValue(value) {
        // Handle null/undefined
        if (value === null || value === undefined) {
          return '—';
        }

        // If it's already a string, check if it's a JSON string or Python dict repr
        if (typeof value === 'string') {
          const trimmed = value.trim();

          // Try to parse as JSON first
          try {
            const parsed = JSON.parse(trimmed);
            if (typeof parsed === 'object' && parsed !== null) {
              return formatObjectAsHtml(parsed);
            }
          } catch {
            // Not valid JSON, continue to try Python dict repr
          }

          // Try to handle Python dict repr (single quotes, True/False/None)
          if ((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
              (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
            const parsed = parsePythonDict(trimmed);
            if (parsed !== null) {
              return formatObjectAsHtml(parsed);
            }
          }

          return escapeHtml(value);
        }

        // If it's an object or array, format it nicely
        if (typeof value === 'object') {
          return formatObjectAsHtml(value);
        }

        // For other primitives, just convert to string
        return escapeHtml(String(value));
      }

      function parsePythonDict(str) {
        // Parse Python dict repr like {'key': 'value', 'num': 123, 'bool': True}
        // This is a simple parser that handles common cases
        try {
          let i = 0;
          const len = str.length;

          function skipWhitespace() {
            while (i < len && /\s/.test(str[i])) i++;
          }

          function parseValue() {
            skipWhitespace();
            if (i >= len) return undefined;

            const ch = str[i];

            // String (single or double quoted)
            if (ch === "'" || ch === '"') {
              return parseString(ch);
            }
            // Object
            if (ch === '{') {
              return parseObject();
            }
            // Array
            if (ch === '[') {
              return parseArray();
            }
            // Number, boolean, None
            return parseLiteral();
          }

          function parseString(quote) {
            i++; // skip opening quote
            let result = '';
            while (i < len) {
              const ch = str[i];
              if (ch === '\\' && i + 1 < len) {
                // Handle escape sequences
                const next = str[i + 1];
                if (next === 'n') { result += '\n'; i += 2; }
                else if (next === 't') { result += '\t'; i += 2; }
                else if (next === 'r') { result += '\r'; i += 2; }
                else if (next === '\\') { result += '\\'; i += 2; }
                else if (next === quote) { result += quote; i += 2; }
                else { result += ch; i++; }
              } else if (ch === quote) {
                i++; // skip closing quote
                return result;
              } else {
                result += ch;
                i++;
              }
            }
            return result; // unclosed string
          }

          function parseObject() {
            i++; // skip '{'
            const obj = {};
            skipWhitespace();
            if (str[i] === '}') { i++; return obj; }

            while (i < len) {
              skipWhitespace();
              // Parse key (must be string)
              const key = parseValue();
              if (typeof key !== 'string') return null;

              skipWhitespace();
              if (str[i] !== ':') return null;
              i++; // skip ':'

              // Parse value
              const val = parseValue();
              obj[key] = val;

              skipWhitespace();
              if (str[i] === '}') { i++; return obj; }
              if (str[i] === ',') { i++; continue; }
              return null; // unexpected character
            }
            return obj;
          }

          function parseArray() {
            i++; // skip '['
            const arr = [];
            skipWhitespace();
            if (str[i] === ']') { i++; return arr; }

            while (i < len) {
              const val = parseValue();
              arr.push(val);

              skipWhitespace();
              if (str[i] === ']') { i++; return arr; }
              if (str[i] === ',') { i++; continue; }
              return null;
            }
            return arr;
          }

          function parseLiteral() {
            // Check for True, False, None, or numbers
            if (str.slice(i, i + 4) === 'True') { i += 4; return true; }
            if (str.slice(i, i + 5) === 'False') { i += 5; return false; }
            if (str.slice(i, i + 4) === 'None') { i += 4; return null; }

            // Parse number
            let numStr = '';
            while (i < len && /[0-9.\-+eE]/.test(str[i])) {
              numStr += str[i];
              i++;
            }
            if (numStr) {
              const num = parseFloat(numStr);
              if (!isNaN(num)) return num;
            }
            return undefined;
          }

          const result = parseValue();
          return result;
        } catch {
          return null;
        }
      }

      function formatObjectAsHtml(obj) {
        if (Array.isArray(obj)) {
          // Format arrays
          if (obj.length === 0) return '<span class="formatted-array">[]</span>';
          const items = obj.map((item, idx) => {
            let formattedItem;
            if (item === null || item === undefined) {
              formattedItem = '<span class="formatted-null">null</span>';
            } else if (typeof item === 'object') {
              formattedItem = formatObjectAsHtml(item);
            } else if (typeof item === 'string') {
              formattedItem = `<span class="formatted-string">${escapeHtml(item)}</span>`;
            } else {
              formattedItem = escapeHtml(String(item));
            }
            return `<div class="formatted-array-item"><span class="formatted-index">[${idx}]</span> ${formattedItem}</div>`;
          }).join('');
          return `<div class="formatted-array">${items}</div>`;
        }

        // Format objects as key-value pairs
        const entries = Object.entries(obj);
        if (entries.length === 0) return '<span class="formatted-object">{}</span>';

        const rows = entries.map(([key, val]) => {
          let formattedVal;
          if (val === null || val === undefined) {
            formattedVal = '<span class="formatted-null">null</span>';
          } else if (typeof val === 'object') {
            formattedVal = formatObjectAsHtml(val);
          } else if (typeof val === 'string') {
            // Show full string without quotes
            formattedVal = `<span class="formatted-string">${escapeHtml(val)}</span>`;
          } else if (typeof val === 'number') {
            formattedVal = `<span class="formatted-number">${val}</span>`;
          } else if (typeof val === 'boolean') {
            formattedVal = `<span class="formatted-boolean">${val}</span>`;
          } else {
            formattedVal = escapeHtml(String(val));
          }
          return `<div class="formatted-row"><span class="formatted-key">${escapeHtml(key)}</span>${formattedVal}</div>`;
        }).join('');

        return `<div class="formatted-object">${rows}</div>`;
      }

      // Event listeners
      el('item-filter').addEventListener('change', (e) => {
        state.itemFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      el('run-winner-filter').addEventListener('change', (e) => {
        state.winnerFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      // Initialize
      loadComparisonData();
    })();
  </script>
</body>
</html>
