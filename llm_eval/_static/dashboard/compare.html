<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLM-Eval • Compare Runs</title>
  <link rel="stylesheet" href="/static/dashboard.css">
  <style>
    /* Compare-specific styles */
    .compare-container {
      padding: var(--space-lg);
      overflow-y: auto;
      height: calc(100vh - 100px);
    }

    .compare-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-lg);
      padding-bottom: var(--space-md);
      border-bottom: 1px solid var(--border-default);
    }

    .compare-title {
      font-size: var(--font-lg);
      font-weight: 600;
      color: var(--text-primary);
    }

    .compare-subtitle {
      font-size: var(--font-sm);
      color: var(--text-muted);
      margin-top: 4px;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      color: var(--accent-primary);
      text-decoration: none;
      font-size: var(--font-sm);
    }

    .back-link:hover {
      text-decoration: underline;
    }

    /* Summary cards grid */
    .compare-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-md);
      margin-bottom: var(--space-xl);
    }

    .run-summary-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
    }

    .run-summary-card .run-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    .run-summary-card .run-name {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      color: var(--text-primary);
      word-break: break-all;
    }

    .run-summary-card .run-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .run-summary-card .stats-row {
      display: flex;
      justify-content: space-between;
      padding: var(--space-xs) 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .run-summary-card .stats-row:last-child {
      border-bottom: none;
    }

    .run-summary-card .stat-label {
      color: var(--text-muted);
      font-size: var(--font-sm);
    }

    .run-summary-card .stat-val {
      font-family: var(--font-mono);
      font-size: var(--font-sm);
      color: var(--text-primary);
    }

    .run-summary-card .stat-val.high { color: var(--success); }
    .run-summary-card .stat-val.mid { color: var(--warning); }
    .run-summary-card .stat-val.low { color: var(--error); }

    /* Comparison Stats Section */
    .comparison-stats {
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-lg);
      margin-bottom: var(--space-xl);
    }

    .comparison-stats h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .stats-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .stats-row {
      display: flex;
      gap: var(--space-sm);
      flex-wrap: wrap;
    }

    .stat-box {
      background: var(--bg-elevated);
      border-radius: 6px;
      padding: var(--space-sm) var(--space-md);
      flex: 1;
      min-width: 120px;
    }

    .stat-box.wide {
      flex: 100%;
      padding: var(--space-md);
    }

    .stat-box .stat-title {
      font-size: var(--font-xs);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
    }

    .stat-box .stat-main {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
    }

    .stat-box.wide .stat-main {
      font-size: var(--font-lg);
    }

    .stat-box .stat-main.positive { color: var(--success); }
    .stat-box .stat-main.negative { color: var(--error); }
    .stat-box .stat-main.neutral { color: var(--text-secondary); }

    .stat-box .stat-detail {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* Win/Loss bars */
    .win-loss-bar {
      display: flex;
      height: 28px;
      border-radius: 4px;
      overflow: hidden;
      margin-top: var(--space-sm);
      gap: 2px;
    }

    .win-loss-bar .segment {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-xs);
      font-weight: 600;
      color: #fff;
      transition: flex 0.3s;
      min-width: 0;
      padding: 0 4px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .win-loss-bar .segment.tie {
      background: var(--text-muted);
    }

    .win-loss-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .win-loss-legend .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: var(--font-xs);
      color: var(--text-secondary);
    }

    .win-loss-legend .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
    }

    .win-loss-legend .legend-count {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    /* Distribution bar */
    .distribution-bar {
      display: flex;
      height: 32px;
      border-radius: 4px;
      overflow: hidden;
      gap: 2px;
      margin-top: var(--space-sm);
    }

    .dist-segment {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 0;
      padding: 2px 4px;
      color: #fff;
      font-size: var(--font-xs);
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .dist-segment .dist-label {
      font-weight: 700;
      font-size: var(--font-sm);
    }

    .dist-segment .dist-count {
      font-size: 10px;
      opacity: 0.9;
    }

    .dist-segment.dist-zero {
      background: var(--error);
    }

    .dist-segment.dist-all {
      background: var(--success);
    }

    .dist-segment.dist-partial {
      background: var(--warning);
    }

    .distribution-legend {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-sm);
      margin-top: var(--space-sm);
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .dist-legend-item {
      display: inline-flex;
      gap: 4px;
    }

    .dist-legend-item strong {
      color: var(--text-secondary);
    }

    /* Metrics comparison table */
    .metrics-comparison {
      margin-bottom: var(--space-xl);
    }

    .metrics-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .metrics-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
    }

    .metrics-table th,
    .metrics-table td {
      padding: var(--space-sm) var(--space-md);
      text-align: left;
      border-bottom: 1px solid var(--border-subtle);
    }

    .metrics-table thead th {
      background: var(--bg-elevated);
      font-size: var(--font-xs);
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metrics-table tbody td {
      font-size: var(--font-sm);
    }

    .metrics-table .metric-name {
      font-family: var(--font-mono);
      color: var(--text-secondary);
    }

    .metrics-table .metric-val {
      font-family: var(--font-mono);
      font-weight: 600;
    }

    .metrics-table .metric-val.high { color: var(--success); }
    .metrics-table .metric-val.mid { color: var(--warning); }
    .metrics-table .metric-val.low { color: var(--error); }

    .metrics-table .metric-val.best {
      background: var(--success-dim);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .metrics-table .diff {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .metrics-table .diff.positive {
      color: var(--success);
    }

    .metrics-table .diff.negative {
      color: var(--error);
    }

    /* Side-by-side items view */
    .items-comparison {
      margin-bottom: var(--space-xl);
    }

    .items-comparison h3 {
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-md);
    }

    .items-filter {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .filter-count {
      font-size: var(--font-sm);
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .filter-count .count-num {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .items-grid {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .item-comparison-row {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      padding: var(--space-md);
    }

    .item-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding-bottom: var(--space-sm);
      border-bottom: 1px solid var(--border-subtle);
    }

    .item-index {
      font-family: var(--font-mono);
      font-size: var(--font-md);
      font-weight: 600;
      color: var(--text-muted);
    }

    .item-input-row,
    .item-expected-row {
      background: var(--bg-elevated);
      padding: var(--space-sm);
      border-radius: 4px;
    }

    .item-input-row .input-label,
    .item-expected-row .expected-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .item-input-row .input-text,
    .item-expected-row .expected-text {
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .item-expected-row {
      background: var(--success-dim);
      border-left: 3px solid var(--success);
    }

    .item-expected-row .expected-label {
      color: var(--success);
    }

    .item-outputs-row {
      display: grid;
      grid-template-columns: repeat(var(--run-count, 2), 1fr);
      gap: var(--space-sm);
      margin-top: var(--space-sm);
    }

    .item-run-output {
      border-left: 3px solid var(--border-default);
      padding-left: var(--space-sm);
      background: var(--bg-elevated);
      border-radius: 0 4px 4px 0;
      padding: var(--space-sm);
    }

    .item-run-output .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
      flex-wrap: wrap;
      gap: 4px;
    }

    .item-run-output .run-label {
      font-size: var(--font-xs);
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .item-run-output .output-badges {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .item-run-output .metric-badge,
    .item-run-output .latency-badge {
      font-family: var(--font-mono);
      font-size: var(--font-xs);
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-surface);
    }

    .item-run-output .metric-badge.high { background: var(--success-dim); color: var(--success); }
    .item-run-output .metric-badge.mid { background: var(--warning-dim); color: var(--warning); }
    .item-run-output .metric-badge.low { background: var(--error-dim); color: var(--error); }

    .item-run-output .latency-badge {
      color: var(--text-muted);
    }

    .item-run-output .output-text {
      font-size: var(--font-sm);
      color: var(--text-secondary);
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 150px;
      overflow-y: auto;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: var(--space-sm);
      margin-top: var(--space-lg);
    }

    .pagination button {
      padding: var(--space-xs) var(--space-md);
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .pagination button:hover:not(:disabled) {
      background: var(--bg-hover);
    }

    .pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination .page-info {
      display: flex;
      align-items: center;
      font-size: var(--font-sm);
      color: var(--text-muted);
    }

    /* Empty/loading states */
    .compare-loading,
    .compare-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 300px;
      color: var(--text-muted);
    }

    .compare-loading .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border-default);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: var(--space-md);
    }
  </style>
</head>
<body>
  <!-- Minimal header -->
  <header class="stats-bar">
    <div class="logo">
      <span class="logo-icon">◈</span>
      <span class="logo-text">LLM-EVAL</span>
    </div>
    <div class="stat-cells">
      <div class="stat-cell">
        <span class="stat-label">COMPARING</span>
        <span class="stat-value" id="run-count">—</span>
      </div>
      <div class="stat-cell">
        <span class="stat-label">TOTAL ITEMS</span>
        <span class="stat-value" id="total-items">—</span>
      </div>
      <div class="stat-cell">
        <span class="stat-label">METRICS</span>
        <span class="stat-value" id="metric-count">—</span>
      </div>
    </div>
  </header>

  <main class="compare-container">
    <div class="compare-loading" id="loading">
      <div class="spinner"></div>
      <span>Loading comparison data...</span>
    </div>

    <div class="compare-empty" id="empty" style="display: none;">
      <div style="font-size: 48px; margin-bottom: var(--space-md);">∅</div>
      <h2>No runs to compare</h2>
      <p>Select at least 2 runs from the dashboard to compare.</p>
      <a href="/" class="back-link">← Back to Dashboard</a>
    </div>

    <div id="compare-content" style="display: none;">
      <div class="compare-header-bar">
        <div>
          <div class="compare-title">Run Comparison</div>
          <div class="compare-subtitle" id="compare-subtitle">Comparing evaluation runs</div>
        </div>
        <a href="/" class="back-link">← Back to Dashboard</a>
      </div>

      <!-- Run summaries -->
      <div class="compare-summary" id="run-summaries"></div>

      <!-- Comparison Statistics -->
      <div class="comparison-stats" id="comparison-stats">
        <h3>Comparison Overview</h3>
        <div class="stats-grid" id="stats-grid"></div>
      </div>


      <!-- Metrics comparison -->
      <div class="metrics-comparison">
        <h3>Metric Averages</h3>
        <table class="metrics-table" id="metrics-table">
          <thead id="metrics-thead"></thead>
          <tbody id="metrics-tbody"></tbody>
        </table>
      </div>

      <!-- Side-by-side items -->
      <div class="items-comparison">
        <h3>Item-by-Item Comparison</h3>
        <div class="items-filter">
          <select id="item-filter" class="filter-select">
            <option value="all">All Items</option>
            <option value="different">Different Outputs</option>
            <option value="errors">With Errors</option>
            <option value="all_correct">All Runs 100%</option>
            <option value="all_wrong">No Run 100%</option>
          </select>
          <select id="run-winner-filter" class="filter-select">
            <option value="any">Any Winner</option>
          </select>
          <span class="filter-count" id="filter-count"></span>
        </div>
        <div class="items-grid" id="items-grid"></div>
        <div class="pagination" id="pagination"></div>
      </div>
    </div>
  </main>

  <script>
    (() => {
      'use strict';

      const COLORS = [
        '#00d4aa', '#00a8ff', '#a855f7', '#f472b6',
        '#fbbf24', '#60a5fa', '#34d399', '#fb923c'
      ];

      const state = {
        runs: [],
        allMetrics: [],
        itemFilter: 'all',
        winnerFilter: 'any',
        page: 1,
        pageSize: 20,
        comparisonStats: null,
      };

      const el = (id) => document.getElementById(id);

      function getSuccessClass(rate) {
        if (rate >= 0.9) return 'high';
        if (rate >= 0.7) return 'mid';
        return 'low';
      }

      function formatPercent(val) {
        if (val === null || val === undefined) return '—';
        return (val * 100).toFixed(1) + '%';
      }

      function formatLatency(ms) {
        if (!ms || ms < 1) return '—';
        if (ms < 1000) return `${Math.round(ms)}ms`;
        return `${(ms / 1000).toFixed(1)}s`;
      }

      function buildDistributionBar(stats) {
        return stats.correctDistribution.map((count, idx) => {
          if (count === 0) return '';
          const pct = (count / stats.totalCompared * 100).toFixed(0);
          const isZero = idx === 0;
          const isAll = idx === state.runs.length;
          const colorClass = isZero ? 'dist-zero' : isAll ? 'dist-all' : 'dist-partial';
          return `<div class="dist-segment ${colorClass}" style="flex: ${count}" title="${idx}/${state.runs.length} correct: ${count} items (${pct}%)">
            <span class="dist-label">${idx}</span>
            <span class="dist-count">${count}</span>
          </div>`;
        }).join('');
      }

      async function loadComparisonData() {
        // Get selected files from sessionStorage
        const filesJson = sessionStorage.getItem('compareRuns');
        if (!filesJson) {
          showEmpty();
          return;
        }

        let files;
        try {
          files = JSON.parse(filesJson);
        } catch {
          showEmpty();
          return;
        }

        if (!Array.isArray(files) || files.length < 2) {
          showEmpty();
          return;
        }

        // Fetch comparison data from API
        const params = files.map(f => 'files=' + encodeURIComponent(f)).join('&');
        try {
          const response = await fetch('/api/compare?' + params);
          const data = await response.json();

          if (!data.runs || data.runs.length < 2) {
            showEmpty();
            return;
          }

          state.runs = data.runs;
          processRuns();
          render();
        } catch (err) {
          console.error('Failed to load comparison:', err);
          showEmpty();
        }
      }

      function processRuns() {
        // Collect all unique metrics
        const metricsSet = new Set();
        for (const run of state.runs) {
          const snap = run.snapshot || {};
          const names = snap.metric_names || run.run?.metric_names || [];
          names.forEach(m => metricsSet.add(m));
        }
        state.allMetrics = Array.from(metricsSet).sort();

        // Update header stats
        el('run-count').textContent = state.runs.length;
        el('metric-count').textContent = state.allMetrics.length;

        // Calculate total items (use max across runs)
        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));
        el('total-items').textContent = maxItems;

        // Calculate comparison statistics
        state.comparisonStats = calculateComparisonStats();

        // Populate winner filter dropdown
        populateWinnerFilter();
      }

      function calculateComparisonStats() {
        const stats = {
          wins: new Array(state.runs.length).fill(0),
          ties: 0,
          totalCompared: 0,
          avgScores: [],
          avgLatencies: [],
          scoreDelta: 0,
          latencyDelta: 0,
          agreementRate: 0,
          allCorrect: 0,
          allWrong: 0,
          passAtK: 0, // Items where at least one run scored 100%
          maxAtK: 0, // Sum of max scores across all items (best possible if you pick best run per item)
          correctDistribution: [], // How many items had 0, 1, 2, ... N runs correct
          overallAvgScore: 0,
          overallAvgLatency: 0,
          errorCounts: [],
          errorTypes: [],
          biggestWins: [],
          itemWinners: [], // For each item, which run won
        };

        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));

        // Initialize correct distribution array (index = number of runs correct, value = count)
        stats.correctDistribution = new Array(state.runs.length + 1).fill(0);

        // Calculate per-run stats
        for (let runIdx = 0; runIdx < state.runs.length; runIdx++) {
          const run = state.runs[runIdx];
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricNames = snap.metric_names || run.run?.metric_names || [];

          let scoreSum = 0, scoreCount = 0, latSum = 0, latCount = 0;
          let timeoutErrors = 0, runtimeErrors = 0, otherErrors = 0;

          for (const row of rows) {
            // Score (first metric)
            if (metricNames.length > 0) {
              const v = (row.metric_values || [])[0];
              const n = parseFloat(v);
              if (!isNaN(n)) { scoreSum += n; scoreCount++; }
            }
            // Latency
            if (row.latency_ms && row.status === 'completed') {
              latSum += row.latency_ms;
              latCount++;
            }
            // Errors
            if (row.status === 'error') {
              const output = (row.output_full || row.output || '').toLowerCase();
              if (output.includes('timeout')) timeoutErrors++;
              else if (output.includes('error')) runtimeErrors++;
              else otherErrors++;
            }
          }

          stats.avgScores.push(scoreCount > 0 ? scoreSum / scoreCount : 0);
          stats.avgLatencies.push(latCount > 0 ? latSum / latCount : 0);
          stats.errorCounts.push(timeoutErrors + runtimeErrors + otherErrors);
          stats.errorTypes.push({ timeout: timeoutErrors, runtime: runtimeErrors, other: otherErrors });
        }

        // Compare items head-to-head
        let agreements = 0;
        for (let i = 0; i < maxItems; i++) {
          const scores = state.runs.map((run, runIdx) => {
            const snap = run.snapshot || {};
            const rows = snap.rows || [];
            const row = rows.find(r => r.index === i);
            if (!row) return null;
            const metricNames = snap.metric_names || run.run?.metric_names || [];
            if (metricNames.length === 0) return null;
            const v = (row.metric_values || [])[0];
            const n = parseFloat(v);
            return isNaN(n) ? null : n;
          });

          const validScores = scores.filter(s => s !== null);

          // Max@K: track the best score for this item across all runs
          if (validScores.length > 0) {
            stats.maxAtK += Math.max(...validScores);
          }

          // Count distribution for ALL items (even those with missing data)
          const numCorrect = scores.filter(s => s !== null && s >= 0.9999).length;
          stats.correctDistribution[numCorrect]++;

          // For head-to-head comparison, need at least 2 valid scores
          if (validScores.length < 2) {
            stats.itemWinners.push(null);
            // Still count pass@k for items with any data
            if (numCorrect > 0) stats.passAtK++;
            if (scores.every(s => s === null || s < 0.0001)) stats.allWrong++;
            if (numCorrect === scores.filter(s => s !== null).length && numCorrect > 0) stats.allCorrect++;
            stats.totalCompared++;
            continue;
          }

          stats.totalCompared++;

          const maxScore = Math.max(...validScores);
          const minScore = Math.min(...validScores);
          const winners = scores.map((s, idx) => s === maxScore ? idx : -1).filter(x => x >= 0);

          // Check if ALL scores are the same (true tie)
          if (maxScore === minScore) {
            stats.ties++;
            stats.itemWinners.push('tie');
          } else if (winners.length === 1) {
            // Clear winner - only one run has the HIGHEST score (beat all others)
            stats.wins[winners[0]]++;
            stats.itemWinners.push(winners[0]);
            // Track biggest wins
            const diff = maxScore - minScore;
            stats.biggestWins.push({ index: i, winner: winners[0], diff, scores });
          } else {
            // Multiple runs tied for the highest score, but didn't beat everyone
            // This counts as a tie (no clear winner)
            stats.ties++;
            stats.itemWinners.push('tie');
          }

          // All correct / all wrong / pass@k (at least one run got 100%)
          // Note: numCorrect was already calculated above
          if (numCorrect === state.runs.length) stats.allCorrect++;
          if (validScores.every(s => s < 0.0001)) stats.allWrong++;
          if (numCorrect > 0) stats.passAtK++;

          // Agreement (runs scored similarly - within 10% of each other)
          const scoreRange = maxScore - minScore;
          if (scoreRange < 0.1) agreements++;
        }

        stats.agreementRate = stats.totalCompared > 0 ? agreements / stats.totalCompared : 0;

        // Calculate overall averages across all runs
        const validScoresAll = stats.avgScores.filter(s => s > 0);
        const validLatenciesAll = stats.avgLatencies.filter(l => l > 0);
        stats.overallAvgScore = validScoresAll.length > 0
          ? validScoresAll.reduce((a, b) => a + b, 0) / validScoresAll.length
          : 0;
        stats.overallAvgLatency = validLatenciesAll.length > 0
          ? validLatenciesAll.reduce((a, b) => a + b, 0) / validLatenciesAll.length
          : 0;

        // Score and latency deltas (comparing first two runs)
        if (state.runs.length >= 2) {
          stats.scoreDelta = stats.avgScores[0] - stats.avgScores[1];
          stats.latencyDelta = stats.avgLatencies[0] - stats.avgLatencies[1];
        }

        // Sort biggest wins
        stats.biggestWins.sort((a, b) => b.diff - a.diff);
        stats.biggestWins = stats.biggestWins.slice(0, 5);

        return stats;
      }

      function populateWinnerFilter() {
        const select = el('run-winner-filter');
        if (!select) return;

        let options = '<option value="any">Any Winner</option>';
        options += '<option value="tie">Ties Only</option>';

        state.runs.forEach((run, idx) => {
          const info = run.run || {};
          const name = info.run_name || `Run ${idx + 1}`;
          options += `<option value="win_${idx}">${name} Won</option>`;
        });

        select.innerHTML = options;
      }

      function showEmpty() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'flex';
        el('compare-content').style.display = 'none';
      }

      function render() {
        el('loading').style.display = 'none';
        el('empty').style.display = 'none';
        el('compare-content').style.display = 'block';

        renderSummaries();
        renderComparisonStats();
        renderMetricsTable();
        renderItems();
      }

      function renderComparisonStats() {
        const container = el('stats-grid');
        if (!container || !state.comparisonStats) return;

        const stats = state.comparisonStats;
        const runNames = state.runs.map((r, i) => r.run?.run_name || `Run ${i + 1}`);

        // Build win/loss bar with proper colors
        const total = stats.totalCompared || 1;
        const winBarSegments = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          const count = stats.wins[idx];
          if (count === 0) return '';
          return `<div class="segment" style="flex: ${count}; background: ${color}">${count}</div>`;
        }).join('');
        const tieSegment = stats.ties > 0
          ? `<div class="segment tie" style="flex: ${stats.ties}">${stats.ties}</div>`
          : '';

        // Build legend
        const legendItems = state.runs.map((_, idx) => {
          const color = COLORS[idx % COLORS.length];
          return `<div class="legend-item">
            <div class="legend-dot" style="background: ${color}"></div>
            <span>${runNames[idx]}:</span>
            <span class="legend-count">${stats.wins[idx]}</span>
          </div>`;
        }).join('');
        const tieLegend = `<div class="legend-item">
          <div class="legend-dot" style="background: var(--text-muted)"></div>
          <span>Ties:</span>
          <span class="legend-count">${stats.ties}</span>
        </div>`;

        container.innerHTML = `
          <div class="stat-box wide">
            <div class="stat-title">Winner Breakdown</div>
            <div class="win-loss-bar">
              ${winBarSegments}
              ${tieSegment}
            </div>
            <div class="win-loss-legend">
              ${legendItems}
              ${tieLegend}
            </div>
            <div class="stat-detail">${stats.totalCompared} items compared</div>
          </div>

          <div class="stats-row">
            <div class="stat-box">
              <div class="stat-title">Pass@${state.runs.length}</div>
              <div class="stat-main positive">${formatPercent(stats.passAtK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Max@${state.runs.length}</div>
              <div class="stat-main positive">${formatPercent(stats.maxAtK / stats.totalCompared)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Score</div>
              <div class="stat-main">${formatPercent(stats.overallAvgScore)}</div>
            </div>

            <div class="stat-box">
              <div class="stat-title">Avg Latency</div>
              <div class="stat-main">${formatLatency(stats.overallAvgLatency)}</div>
            </div>
          </div>

          <div class="stat-box wide">
            <div class="stat-title">Correct Distribution (how many runs got each item right)</div>
            <div class="distribution-bar">
              ${buildDistributionBar(stats)}
            </div>
          </div>
        `;
      }

      function renderSummaries() {
        const container = el('run-summaries');
        container.innerHTML = state.runs.map((run, idx) => {
          const info = run.run || {};
          const snap = run.snapshot || {};
          const stats = snap.stats || {};
          const color = COLORS[idx % COLORS.length];
          const successRate = (stats.completed || 0) / (stats.total || 1);
          const successClass = getSuccessClass(successRate);

          return `
            <div class="run-summary-card">
              <div class="run-header">
                <div class="run-color-dot" style="background: ${color}"></div>
                <div class="run-name">${info.run_name || 'Run ' + (idx + 1)}</div>
              </div>
              <div class="run-meta">
                <span class="tag task">${info.dataset_name || '—'}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Total Items</span>
                <span class="stat-val">${stats.total || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Completed</span>
                <span class="stat-val">${stats.completed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Failed</span>
                <span class="stat-val ${stats.failed > 0 ? 'low' : ''}">${stats.failed || 0}</span>
              </div>
              <div class="stats-row">
                <span class="stat-label">Success Rate</span>
                <span class="stat-val ${successClass}">${formatPercent(successRate)}</span>
              </div>
            </div>
          `;
        }).join('');
      }

      function renderMetricsTable() {
        const thead = el('metrics-thead');
        const tbody = el('metrics-tbody');

        // Header row
        thead.innerHTML = `
          <tr>
            <th>Metric</th>
            ${state.runs.map((run, idx) => {
              const info = run.run || {};
              const color = COLORS[idx % COLORS.length];
              return `<th><span style="display:inline-block;width:10px;height:10px;background:${color};border-radius:2px;margin-right:6px;"></span>${info.run_name || 'Run ' + (idx + 1)}</th>`;
            }).join('')}
          </tr>
        `;

        // Calculate metric averages and latency for each run
        const runMetricAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          const metricNames = snap.metric_names || run.run?.metric_names || [];
          const avgs = {};

          for (const metric of state.allMetrics) {
            const idx = metricNames.indexOf(metric);
            if (idx === -1) {
              avgs[metric] = null;
              continue;
            }

            let sum = 0, count = 0;
            for (const row of rows) {
              const vals = row.metric_values || [];
              const v = vals[idx];
              const n = parseFloat(v);
              if (!isNaN(n)) {
                sum += n;
                count++;
              }
            }
            avgs[metric] = count > 0 ? sum / count : null;
          }
          return avgs;
        });

        // Calculate average latency for each run
        const runLatencyAvgs = state.runs.map(run => {
          const snap = run.snapshot || {};
          const rows = snap.rows || [];
          let sum = 0, count = 0;
          for (const row of rows) {
            if (row.latency_ms && row.status === 'completed') {
              sum += row.latency_ms;
              count++;
            }
          }
          return count > 0 ? sum / count : null;
        });

        // Find best (lowest) latency
        const bestLatency = Math.min(...runLatencyAvgs.filter(v => v !== null));

        // Find best value for each metric
        const bestValues = {};
        for (const metric of state.allMetrics) {
          let best = -Infinity;
          for (const avgs of runMetricAvgs) {
            if (avgs[metric] !== null && avgs[metric] > best) {
              best = avgs[metric];
            }
          }
          bestValues[metric] = best > -Infinity ? best : null;
        }

        // Render rows - metrics first, then latency
        const metricRows = state.allMetrics.map(metric => {
          const cells = runMetricAvgs.map(avgs => {
            const val = avgs[metric];
            if (val === null) return '<td class="metric-val">—</td>';
            const isBest = val === bestValues[metric] && state.runs.length > 1;
            const cls = getSuccessClass(val);
            return `<td class="metric-val ${cls} ${isBest ? 'best' : ''}">${formatPercent(val)}</td>`;
          }).join('');

          return `
            <tr>
              <td class="metric-name">${metric}</td>
              ${cells}
            </tr>
          `;
        }).join('');

        // Latency row
        const latencyCells = runLatencyAvgs.map(val => {
          if (val === null) return '<td class="metric-val">—</td>';
          const isBest = val === bestLatency && state.runs.length > 1;
          return `<td class="metric-val ${isBest ? 'best' : ''}" style="${isBest ? 'background: var(--success-dim);' : ''}">${formatLatency(val)}</td>`;
        }).join('');

        const latencyRow = `
          <tr>
            <td class="metric-name">Avg Latency</td>
            ${latencyCells}
          </tr>
        `;

        tbody.innerHTML = metricRows + latencyRow;
      }

      function getFilteredItems() {
        // Build aligned item list across runs
        const maxItems = Math.max(...state.runs.map(r => (r.snapshot?.rows || []).length));
        const items = [];
        const stats = state.comparisonStats;

        for (let i = 0; i < maxItems; i++) {
          const rowData = state.runs.map(run => {
            const rows = run.snapshot?.rows || [];
            return rows.find(r => r.index === i) || null;
          });

          // Get scores for this item
          const scores = rowData.map((row, runIdx) => {
            if (!row) return null;
            const run = state.runs[runIdx];
            const metricNames = run.snapshot?.metric_names || run.run?.metric_names || [];
            if (metricNames.length === 0) return null;
            const v = (row.metric_values || [])[0];
            const n = parseFloat(v);
            return isNaN(n) ? null : n;
          });
          const validScores = scores.filter(s => s !== null);

          // Apply item filter
          if (state.itemFilter === 'different') {
            const outputs = rowData.map(r => r?.output_full || r?.output || '').filter(o => o);
            const uniqueOutputs = new Set(outputs);
            if (uniqueOutputs.size <= 1) continue;
          } else if (state.itemFilter === 'errors') {
            const hasError = rowData.some(r => r?.status === 'error');
            if (!hasError) continue;
          } else if (state.itemFilter === 'all_correct') {
            // All runs got 100% (matches distribution "all correct")
            if (validScores.length < 2 || !validScores.every(s => s >= 0.9999)) continue;
          } else if (state.itemFilter === 'all_wrong') {
            // No run got 100% (matches distribution "0 correct")
            if (validScores.length < 2 || validScores.some(s => s >= 0.9999)) continue;
          }

          // Apply winner filter
          if (state.winnerFilter !== 'any' && stats) {
            const winner = stats.itemWinners[i];
            if (state.winnerFilter === 'tie') {
              // Only show ties (all runs same score OR multiple tied for highest)
              if (winner !== 'tie') continue;
            } else if (state.winnerFilter.startsWith('win_')) {
              const winnerIdx = parseInt(state.winnerFilter.replace('win_', ''), 10);
              // Only show items where this run was the SOLE winner (beat all others)
              if (winner !== winnerIdx) continue;
            }
          }

          items.push({ index: i, rowData });
        }

        return items;
      }

      function renderItems(scrollToTop = false) {
        const container = el('items-grid');
        const paginationEl = el('pagination');
        const filterCountEl = el('filter-count');
        const items = getFilteredItems();

        // Update filter count display
        filterCountEl.innerHTML = `<span class="count-num">${items.length}</span> items`;

        // Set CSS variable for grid columns
        container.style.setProperty('--run-count', state.runs.length);

        // Pagination
        const totalPages = Math.max(1, Math.ceil(items.length / state.pageSize));
        if (state.page > totalPages) state.page = totalPages;
        const start = (state.page - 1) * state.pageSize;
        const pageItems = items.slice(start, start + state.pageSize);

        if (items.length === 0) {
          container.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted);">No items match the current filter</div>';
          paginationEl.innerHTML = '';
          return;
        }

        container.innerHTML = pageItems.map(({ index, rowData }) => {
          // Get input and expected from any available row
          const inputRow = rowData.find(r => r);
          const input = inputRow?.input_full || inputRow?.input || '—';
          const expected = inputRow?.expected_full || inputRow?.expected || '';

          const outputCells = rowData.map((row, runIdx) => {
            const color = COLORS[runIdx % COLORS.length];
            const runInfo = state.runs[runIdx]?.run || {};

            if (!row) {
              return `
                <div class="item-run-output" style="border-left-color: ${color}">
                  <div class="output-header">
                    <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)}</span>
                  </div>
                  <div class="output-text" style="color:var(--text-muted);font-style:italic;">No data</div>
                </div>
              `;
            }

            const output = row.output_full || row.output || '—';
            const status = row.status || 'pending';
            const latencyMs = row.latency_ms;

            // Get first metric value for badge
            const metricVals = row.metric_values || [];
            let metricBadge = '';
            if (metricVals.length > 0) {
              const v = parseFloat(metricVals[0]);
              if (!isNaN(v)) {
                const cls = getSuccessClass(v);
                metricBadge = `<span class="metric-badge ${cls}">${formatPercent(v)}</span>`;
              }
            }

            // Latency badge
            const latencyBadge = latencyMs ? `<span class="latency-badge">${formatLatency(latencyMs)}</span>` : '';

            return `
              <div class="item-run-output" style="border-left-color: ${color}">
                <div class="output-header">
                  <span class="run-label"><span style="display:inline-block;width:8px;height:8px;background:${color};border-radius:2px;"></span> ${runInfo.run_name || 'Run ' + (runIdx + 1)}</span>
                  <span class="output-badges">${metricBadge}${latencyBadge}</span>
                </div>
                <div class="output-text ${status === 'error' ? 'low' : ''}">${escapeHtml(output)}</div>
              </div>
            `;
          }).join('');

          // Only show expected row if there's expected output
          const expectedRow = expected ? `
              <div class="item-expected-row">
                <div class="expected-label">Expected Output</div>
                <div class="expected-text">${escapeHtml(expected)}</div>
              </div>
          ` : '';

          return `
            <div class="item-comparison-row">
              <div class="item-header">
                <span class="item-index">#${index + 1}</span>
              </div>
              <div class="item-input-row">
                <div class="input-label">Input</div>
                <div class="input-text">${escapeHtml(input)}</div>
              </div>
              ${expectedRow}
              <div class="item-outputs-row" style="--run-count: ${state.runs.length}">
                ${outputCells}
              </div>
            </div>
          `;
        }).join('');

        // Pagination controls
        paginationEl.innerHTML = `
          <button id="prev-page" ${state.page <= 1 ? 'disabled' : ''}>← Prev</button>
          <span class="page-info">Page ${state.page} of ${totalPages}</span>
          <button id="next-page" ${state.page >= totalPages ? 'disabled' : ''}>Next →</button>
        `;

        el('prev-page').onclick = () => { state.page--; renderItems(true); };
        el('next-page').onclick = () => { state.page++; renderItems(true); };

        // Scroll to top of items grid if requested
        if (scrollToTop) {
          container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
      }

      // Event listeners
      el('item-filter').addEventListener('change', (e) => {
        state.itemFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      el('run-winner-filter').addEventListener('change', (e) => {
        state.winnerFilter = e.target.value;
        state.page = 1;
        renderItems();
      });

      // Initialize
      loadComparisonData();
    })();
  </script>
</body>
</html>
